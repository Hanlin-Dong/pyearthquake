<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>pyearthquake API documentation</title>
<meta name="description" content="Introduction
â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyearthquake</code></h1>
</header>
<section id="section-intro">
<h1 id="introduction">Introduction</h1>
<p><a title="pyearthquake" href="#pyearthquake"><code>pyearthquake</code></a> is a light-weight module with basic earthquake engineering utilities.
The aim of this module is to help engineers play with earthquakes by python programming.</p>
<h2 id="features"><em>Features</em></h2>
<ol>
<li>Convert .AT2 file downloaded from PEER database to nicely aligned form.
</li>
<li>Select and match ground motions to the target spectrum with Monte Carlo simulation and Least Square optimization.</li>
<li>Beautify the ground motions by truncating, trimming, changing dt, and renaming.</li>
<li>Store a suite of motions in a single file or separate files.</li>
<li>Generate displacement spectrums and pesudo acceleration spectrums.</li>
<li>Inspect a suite or a motion with nice html interactive plots, thanks to <a href="https://plot.ly">plotly</a>.
</li>
<li>Create Code Spectrums. Currently support Chinese Code.</li>
</ol>
<h2 id="fact-sheet">Fact Sheet</h2>
<p>Version: 1.0 <br>
Author: <a href="http://www.hanlindong.com">Hanlin Dong</a><br>
License: MIT<br>
Last Update: 2020-04-08
</p>
<h2 id="content-briefing">Content Briefing</h2>
<p>Currently, it has three main classes: <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a>, <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a>, and <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a></p>
<p><a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a> : a class storing seismic spectrum.<br>
Some static methods are created confining to Code Spectrums.</p>
<p><a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a> : a class storing acceleration timehistory.<br>
Motion has utility functions to nicely parse PEER motion file.<br>
Motion also generates spectrums.</p>
<p><a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a> : a class storing a suite of motions and their target spectrum.<br>
Suite has utilities to load a PEER file folder.<br>
Suite has optimization functions to select a bunch of earthquakes out of a large number of earthquakes
with Monte Carlo simulation and bounded least square optimization.
The advantage is that the shape of the accels is not changed unlike wavelet methods,
but the average match result is still good.<br>
Suite can write all the acceleration files seperately or integrally. <br>
Suite can plot all the accelerations and spectrums interactively for users to inspect.<br>
Suite can generate .tcl file to be used in OpenSees.
</p>
<p>All the classes mentioned above can be stored as string file.
Currently they are json files with ext: .spectrum, .motion, .suite.
These files can be read by static methods in every class.</p>
<h2 id="change-log">Change log:</h2>
<p>2020-04-08 13:53:32 v1.0
</p>
<ul>
<li>Join the three classes to one single file, refactor some functions.
</li>
<li>Unify some methods, and create good documentation.</li>
<li>Add plotly interactive plots.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Introduction
============

`pyearthquake` is a light-weight module with basic earthquake engineering utilities.
The aim of this module is to help engineers play with earthquakes by python programming.

*Features*
--------

1. Convert .AT2 file downloaded from PEER database to nicely aligned form.  
2. Select and match ground motions to the target spectrum with Monte Carlo simulation and Least Square optimization.
3. Beautify the ground motions by truncating, trimming, changing dt, and renaming.
4. Store a suite of motions in a single file or separate files.
5. Generate displacement spectrums and pesudo acceleration spectrums.
6. Inspect a suite or a motion with nice html interactive plots, thanks to [plotly](https://plot.ly).  
7. Create Code Spectrums. Currently support Chinese Code.

Fact Sheet  
----------  
Version: 1.0   
Author: [Hanlin Dong](http://www.hanlindong.com)  
License: MIT  
Last Update: 2020-04-08   

Content Briefing
----------------

Currently, it has three main classes: `Spectrum`, `Motion`, and `Suite`

`Spectrum` : a class storing seismic spectrum.  
    Some static methods are created confining to Code Spectrums.

`Motion` : a class storing acceleration timehistory.  
    Motion has utility functions to nicely parse PEER motion file.  
    Motion also generates spectrums.

`Suite` : a class storing a suite of motions and their target spectrum.  
    Suite has utilities to load a PEER file folder.  
    Suite has optimization functions to select a bunch of earthquakes out of a large number of earthquakes
        with Monte Carlo simulation and bounded least square optimization.
        The advantage is that the shape of the accels is not changed unlike wavelet methods,
        but the average match result is still good.  
    Suite can write all the acceleration files seperately or integrally.   
    Suite can plot all the accelerations and spectrums interactively for users to inspect.  
    Suite can generate .tcl file to be used in OpenSees.  

All the classes mentioned above can be stored as string file.
    Currently they are json files with ext: .spectrum, .motion, .suite.
    These files can be read by static methods in every class.

Change log:
-----------
2020-04-08 13:53:32 v1.0  

- Join the three classes to one single file, refactor some functions.  
- Unify some methods, and create good documentation.
- Add plotly interactive plots.
&#39;&#39;&#39;

import os
import re
import json
import random
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from scipy.signal import lsim
from scipy.interpolate import interp1d
from scipy.optimize import least_squares


class Spectrum():
    &#39;&#39;&#39;A class storing a spectrum.  
    It can be init-ed simply with (periods, spectrum) sampling points.  
    It can also be init-ed by static functions to generate Code-confined spectrums.

    Parameters  
    ----------  
    `periods` : List, numpy.ndarray  
        List of sampling periods.  
        It can be generated by the static function `Spectrum.periods_standard` .
        Otherwise, users can specify desired period sampling points.  

    `spectrum` : List, numpy.ndarray  
        List of the spectrum points corresponding to sampling periods.  
    &#39;&#39;&#39;

    def __init__(self, periods, spectrum):
        self.periods = np.array(periods)
        &#39;&#39;&#39;numpy.ndarray, sampling periods&#39;&#39;&#39;
        self.spectrum = np.array(spectrum)
        &#39;&#39;&#39;numpy.ndarray, spectrum corresponding to sampling periods.&#39;&#39;&#39;

    def match(self, target, start, end, step=0.1):
        &#39;&#39;&#39;Match the current spectrum with a target spectrum. Use Least Square method.  

        Parameters  
        ----------  
        `target` : `Spectrum`  
            the spectrum to be matched.  

        `start`, `end` : float  
            the matching period boundaries.  

        `step` : float
            evenly sample the periods with the step.

        Returns
        -------
        `coefficient` : float  
            the coefficient to match the current spectrum to the target.

        `srss` : float   
            the srss after match.
        &#39;&#39;&#39;
        periods = np.arange(start, end+step, step)
        this_spectrum = np.array([self.get(p) for p in periods])
        that_spectrum = np.array([target.get(p) for p in periods])
        coefficient = sum(this_spectrum * that_spectrum) / sum(this_spectrum ** 2)
        srss = (np.sum((this_spectrum * coefficient - that_spectrum) ** 2)) ** 0.5
        return coefficient, srss

    def get(self, period):
        &#39;&#39;&#39;Get the spectrum value. Either a list or a number is accepted.  
        If the period exceeds the largest sampling period, the last spectrum value is returned.  
        The spectrum value not on sampling points are linearly interpolated.  

        Parameters
        ----------
        `period` : number, list, numpy.ndarray  
            The interested period.

        Returns
        -------
        `spectrum` : number, numpy.ndarray  
            if period is list-like, return a ndarray.
            if period is a number, return a number.
        &#39;&#39;&#39;
        if not hasattr(period, &#39;__iter__&#39;):
            i = self.periods.searchsorted(period)
            if self.periods[i] == period:
                return self.spectrum[i]
            elif i &gt;= len(self.periods):
                print(&#34;Warning: given period exceeds the sampling range.&#34;)
                return self.spectrum[-1]
            else:
                return self.spectrum[i] - (self.spectrum[i]-self.spectrum[i-1]) / (self.periods[i] - self.periods[i-1]) * (self.periods[i] - period)
        else:
            return np.array([self.get(p) for p in period])

    def scale(self, factor_x=1, factor_y=1):
        &#39;&#39;&#39;Scale the spectrum.

        Parameters
        ----------
        `factor_x` : number  
            scaling factor in x direction (periods)  

        `factor_y` : number  
            scaling factor in y direction (spectrum)

        Returns
        -------
        `spectrum` : `Spectrum`
        &#39;&#39;&#39;
        return Spectrum(periods=self.periods*factor_x, spectrum=self.spectrum*factor_y)

    def plot(self, filename=None, engine=&#39;pyplot&#39;):
        &#39;&#39;&#39;Plot the spectrum.

        Parameters
        ----------
        `filename` : string, None  
            if None, show it. Else, save it to the filename  

        `engine` : &#39;pyplot&#39; or &#39;plotly&#39;  
            Plot engine.

        Outputs
        -------
        A file with name `filename`.png or `filename`.html will be generated.
        &#39;&#39;&#39;
        if engine == &#39;pyplot&#39;:
            plt.figure(figsize=(4, 3))
            plt.plot(self.periods, self.spectrum, marker=&#39;o&#39;)
            plt.xlabel(&#39;Period (s)&#39;)
            plt.ylabel(&#39;Spetrum&#39;)
            plt.xlim([0, self.periods[-1]])
            if filename is None:
                plt.show()
            else:
                plt.savefig(filename+&#39;.png&#39;, dpi=200)
        elif engine == &#39;plotly&#39;:
            fig = go.Figure()
            fig.add_scatter(dict(
                x=&#39;self.periods&#39;,
                y=&#39;self.spectrum&#39;,
                mode=&#39;lines+markers&#39;,
            ))
            if filename is None:
                fig.show()
            else:
                fig.write_html(filename+&#39;.html&#39;)
        else:
            print(&#39;ERROR: engine should be in &#34;pyplot&#34; or &#34;plotly&#34;&#39;)

    def to_dict(self):
        &#39;&#39;&#39;Convert the instance properties to a dict.  

        Returns
        -------
        `it` : dict
        &#39;&#39;&#39;
        return dict(
            periods=self.periods.tolist(),
            spectrum=self.spectrum.tolist()
        )

    def to_json(self):
        &#39;&#39;&#39;Convert the properties to json.  

        Returns
        -------
        `json` : string  
        &#39;&#39;&#39;
        return json.dumps(self.to_dict())

    def save(self, filename):
        &#39;&#39;&#39;Save the spectrum to a file. Currently use json form.  

        Parameters
        ----------
        `filename` : string  
            The file name to be saved.   
            The extension &#39;.spectrum&#39; will be automatically added.  

        Outputs
        -------
        A file with name `filename`.spectrum will be generated.
        &#39;&#39;&#39;
        with open(filename + &#39;.spectrum&#39;, &#39;w&#39;) as f:
            f.write(self.to_json())

    def write_csv(self, filename):
        &#39;&#39;&#39;Write the spectrum to a csv file.  

        Parameters
        ----------
        `filename` : string  
            The extension &#39;.csv&#39; will be automatically added.

        Outputs
        -------
        A file named `filename`.csv will be generated.
        &#39;&#39;&#39;
        np.savetxt(filename+&#39;.csv&#39;, np.vstack(
            [self.periods, self.spectrum]).T, fmt=&#34;%.3f,%.7f&#34;, header=&#39;Period,Spectrum&#39;)

    @staticmethod
    def read_csv(filename):
        &#39;&#39;&#39;Create an instance by reading the written csv file.  

        Parameters
        ----------
        `filename` : string  
            The filename to read.

        Returns
        -------
        `spectrum` : `Spectrum`  
            New instance.
        &#39;&#39;&#39;
        if not filename.endswith(&#39;.csv&#39;):
            filename += &#39;.csv&#39;
        data = np.loadtxt(filename, delimiter=&#39;,&#39;)
        return Spectrum(periods=data[:, 0], spectrum=data[:, 1])

    @staticmethod
    def read_dict(it):
        &#39;&#39;&#39;Create an instance from the dict.  

        Parameters
        ----------
        `it` : dict  
            The dict generated by `Spectrum.to_dict`

        Returns
        -------
        `spectrum` : `Spectrum`  
            New instance.
        &#39;&#39;&#39;
        return Spectrum(periods=it[&#39;periods&#39;], spectrum=it[&#39;spectrum&#39;])

    @staticmethod
    def read_json(string):
        &#39;&#39;&#39;Create an instance from json string.  

        Parameters
        ----------
        `string` : str  
            The json string 

        Returns
        -------
        `spectrum` : `Spectrum`  
            New instance.
        &#39;&#39;&#39;
        it = json.loads(string)
        return Spectrum.read_dict(it)

    @staticmethod
    def load(filename):
        &#39;&#39;&#39;Load the spectrum from file.  

        Parameters
        ----------
        `filename` : str  

        Returns
        -------
        `spectrum` : `Spectrum`  
            New instance.
        &#39;&#39;&#39;
        if not filename.endswith(&#39;.spectrum&#39;):
            filename += &#39;.spectrum&#39;
        with open(filename, &#39;r&#39;) as f:
            string = f.read()
        return Spectrum.read_json(string)

    @staticmethod
    def periods_standard(until=6):
        &#39;&#39;&#39;Get a standard sampling of the periods.  
        The sampling points are more sparse with the increase of period.  

        Parameters
        ----------  
        `until` : number  
            The end of the period sampling list. It should &gt;= 4.0.

        Returns
        -------
        `periods` : numpy.ndarray  
            The standard sampling points.
        &#39;&#39;&#39;
        assert until &gt;= 4
        return np.hstack([np.arange(0, 0.2, 0.01),
                          np.arange(0.2, 0.5, 0.02),
                          np.arange(0.5, 1.0, 0.05),
                          np.arange(1.0, 2.0, 0.1),
                          np.arange(2.0, 4.0, 0.2),
                          np.arange(4.0, until+0.5, 0.5)])

    @staticmethod
    def chinese_point(period, intensity, major, site, group, damping=0.05):
        &#39;&#39;&#39;Get spectrum point for Chinese code, given a period.  

        Parameters
        ----------  
        `period` : number  
            The given period.  

        `intensity` : number  
            Intensity represented by a number.   
            Use 7.5 or 8.5 for half-level intensity.  

        `major` : boolean
            If True, it&#39;s for major (rare) earthquake.  
            If False, for minor (frequent) earthquake.  

        `site` : int
            Site number (Roman number in the code. 0 for I0, 1 for I1.)  

        `group` : int  
            Site class (Chinese number in the code.)  

        `damping` : float  
            Spectrum damping.  

        Returns
        -------  
        `value` : float
            the specific spectrum point value corresponding to the period.  
        &#39;&#39;&#39;
        # alpha max
        if intensity == 6:
            alphamax = 0.28 if major else 0.04
        elif intensity == 7:
            alphamax = 0.50 if major else 0.08
        elif intensity == 7.5:
            alphamax = 0.72 if major else 0.12
        elif intensity == 8:
            alphamax = 0.9 if major else 0.16
        elif intensity == 8.5:
            alphamax = 1.2 if major else 0.24
        elif intensity == 9:
            alphamax = 1.40 if major else 0.32
        else:
            raise(&#34;ERROR: intensity not in [6, 7, 7.5, 8, 8.5, 9]&#34;)
        # tg
        tg_table = [[0.20, 0.25, 0.35, 0.45, 0.65],
                    [0.25, 0.3, 0.4, 0.55, 0.75],
                    [0.3, 0.35, 0.45, 0.65, 0.9]]
        assert group in [1, 2, 3] and site in [0, 1, 2, 3, 4]
        tg = tg_table[group-1][site]
        # other parameters
        gamma = 0.9 + (0.05 - damping) / (0.3 + 6*damping)
        eta1 = 0.02 + (0.05 - damping) / (4 + 32*damping)
        eta2 = 1 + (0.05 - damping) / (0.08 + 1.6*damping)
        # calculate
        if period &lt; 0.1:
            return ((10*eta2 - 4.5) * period + 0.45) * alphamax
        elif period &lt; tg:
            return eta2 * alphamax
        elif period &lt; 5*tg:
            return (tg/period)**gamma * eta2 * alphamax
        elif period &lt;= 6:
            return (eta2 * 0.2**gamma - eta1 * (period-5*tg)) * alphamax
        else:
            return (eta2 * 0.2**gamma - eta1 * (6-5*tg)) * alphamax

    @staticmethod
    def chinese(intensity=8, major=True, site=3, group=2, damping=0.05):
        &#39;&#39;&#39;Return a new spectrum instance that confines to Chinese Code.  
        Use `Spectrum.periods_standard` to get sampling periods.  

        Parameters
        ----------
        refer to `Spectrum.chinese_point`

        Returns
        -------
        `spectrum` : `Spectrum`
        &#39;&#39;&#39;
        periods = Spectrum.periods_standard(until=6)
        spectrum = [Spectrum.chinese_point(p, 
                                           intensity=intensity,
                                           major=major,
                                           site=site,
                                           group=group,
                                           damping=damping) for p in periods]
        return Spectrum(periods, spectrum)


class Motion(object):
    &#39;&#39;&#39;A class plays with ground motion. Store accel time history and accel spectrum only.  
    &#39;&#39;&#39;

    def __init__(self, folder, name, damping=0.05):
        &#39;&#39;&#39;
        Parameters
        ----------
        `folder` : str   
            the folder this motion is stored.

        `name` : str  
            The motion name. The motion will be saved to &#39;{folder}/{name}.motion&#39;

        `damping` : float  
            The damping ratio of the motion spectrum.  
        &#39;&#39;&#39;
        self.folder = folder
        &#39;&#39;&#39;str. See `Motion`.&#39;&#39;&#39;
        os.makedirs(folder, exist_ok=True)
        self.name = name
        &#39;&#39;&#39;str. See `Motion`.&#39;&#39;&#39;
        self.accel = None
        &#39;&#39;&#39;numpy.ndarray. Acceleration time history with evenly distributed sampling points.&#39;&#39;&#39;
        self.dt = None
        &#39;&#39;&#39;float. Acceleration time sampling delta t.&#39;&#39;&#39;
        self.information = &#39;&#39;
        &#39;&#39;&#39;str. Store massive infomation about the motion. &#39;&#39;&#39;
        self.spectrum = None
        &#39;&#39;&#39;`Spectrum`. The spectrum of the motion.&#39;&#39;&#39;
        self.damping = damping
        &#39;&#39;&#39;float. The damping ratio of the spectrum. Note: init with 0.05.&#39;&#39;&#39;

    def get_PGA(self):
        &#39;&#39;&#39;
        Returns
        -------
        `value` : float  
            The peak ground acceleration.  
        &#39;&#39;&#39;
        return np.max(abs(self.accel))

    def get_duration(self):
        &#39;&#39;&#39;
        Returns
        -------
        `value` : float  
            The duration of the motion.  
        &#39;&#39;&#39;
        return (len(self.accel) - 1) * self.dt

    def get_times(self):
        &#39;&#39;&#39;
        Returns
        -------
        `value` : numpy.ndarray  
            The time series of the motion  
        &#39;&#39;&#39;
        return np.arange(len(self.accel)) * self.dt

    def generate_spectrum(self, periods=None):
        &#39;&#39;&#39;Use scipy LTS signal processing module to generate the spectrum.  
        Note that the accel spectrum is pseudo-spectrum derived from disp spectrum.  
        So it&#39;s only accurate when damping is small.  
        If `Motion.dt` is still None, which usually occurs if the PEER file is not well formated, 
            a blank spectrum will be returned.  

        Parameters
        ----------
        `periods` : List-like, None    
            The period sampling points.   
            If is None, `Spectrum.periods_standard` will be called.

        Returns
        -------
        `spectrum` : `Spectrum`  
            The generated spectrum.

        Outputs
        -------
        `Motion.spectrum` will be changed.
        &#39;&#39;&#39;
        if periods is None:
            periods = Spectrum.periods_standard()
        if self.dt is not None:
            print(&#34;Generating spectrum ...&#34;)
            omegas = 2 * np.pi / periods[1:]
            num = np.array([-1])
            spectrum = np.zeros(len(periods))
            spectrum[0] = self.get_PGA()
            for i, omega in enumerate(omegas):
                den = np.array([1, 2*self.damping*omega, omega**2])
                _, y, _ = lsim((num, den), self.accel, self.get_times())
                spectrum[i+1] = np.max(abs(y)) * omega ** 2
            self.spectrum = Spectrum(periods, spectrum)
        else:
            print(&#34;Dt is not known. Assigning empty spectrum.&#34;)
            self.spectrum = Spectrum(periods=[], spectrum=[])
        return self.spectrum

    def load_peer(self, peer_filename):
        &#39;&#39;&#39;Load acceleration time-history files downloaded from PEER.  
        The strings in the file will be parsed and also stored in self.information.  

        Parameters
        ----------
        `peer_filename` : str

        Outputs
        -------
        `Motion.dt`, `Motion.accel`, `Motion.information`, `Motion.spectrum` will all be changed.  
        &#39;&#39;&#39;
        self.information += f&#39;peer_filename: {peer_filename}&#39;
        try:
            f = open(peer_filename, &#39;r&#39;)
            for _ in range(3):
                self.information += f.readline()
            s = f.readline()
            self.information += s
            re_dt = re.compile(r&#34;.*[ 0](\.[0-9]*) ?SEC&#34;)
            mt = re_dt.match(s)
            try:
                self.dt = float(mt.group(1).replace(&#39;.&#39;, &#39;0.&#39;))
                print(f&#39;Extracted dt = {self.dt:.4f}&#39;)
            except:
                print(f&#39;ERROR: cannot find dt from {s}&#39;)
                self.dt = 0.000001
            series = []
            datastring = f.readlines()
            for dtline in datastring:
                for dt in dtline.split(&#34;  &#34;):
                    if dt:
                        try:
                            series.append(float(dt.replace(&#34;.&#34;, &#34;0.&#34;)))
                        except ValueError:
                            break
            self.accel = np.array(series)
            print(f&#39;Extracted npts = {len(self.accel)}&#39;)
        except IOError:
            print(f&#39;No file named {self.name} is found.&#39;)

    def convert_peer(self, peer_filename):
        &#39;&#39;&#39;A recipe to convert the peer acceleration file to the .motion file.  

        Parameters
        ----------
        `peer_filename` : str  

        `folder` : str  
            the folder to save .motion file.

        Outputs
        -------
        A .motion file will be created in `folder` with the PEER filename.
        &#39;&#39;&#39;
        print(f&#39;Converting PEER file {peer_filename} to folder {self.folder} with name {self.name}&#39;)
        self.load_peer(peer_filename)
        self.generate_spectrum()
        self.save()

    def trim(self, new_name, new_folder=None, left=1.0e-3, right=1.0e-3, prepend_zero=True, log=True, log_folder=None):
        &#39;&#39;&#39;Trim the motion with two coefficients of PGA.  
        This method is used when a long near-zero time-history is stored in the data file.  

        Parameters
        ----------
        `new_name` : str  

        `new_folder` : str, None  

        `left`, `right` : float 
            The coefficient of PGA to trim the time history.
            Search from left or right, when the target point is found,
            search for the nearest near-zero point. Then trim off the small values.  


        `prepend_zero` : boolean  
            If True, prepend a zero value to the trimmed acceleration.

        `log` : boolean  
            If the log picture will be generated.

        `log_folder` : str, None
            Path for the folder to save the trim logs.
            If None, save in the previous folder.

        Returns
        -------
        `motion` : `Motion`  
            The trimmed motion.

        Outputs
        -------
        If log, plot a figure in log_folder named &#39;{new_name}_trimlog.png&#39;
        &#39;&#39;&#39;
        mo = self.copy()
        mo.name = new_name
        mo.folder = new_folder if new_folder is not None else self.folder
        pga = self.get_PGA()
        # search left
        i = 0
        while abs(self.accel[i]) &lt; pga * left:
            i += 1
        while i &gt; 0 and self.accel[i] * self.accel[i-1] &gt; 0:
            i -= 1
        i_left = i
        # search right
        i = -1
        while abs(self.accel[i]) &lt; pga * right:
            i -= 1
        while i &lt; -1 and self.accel[i] * self.accel[i+1] &gt; 0:
            i += 1
        i_right = len(self.accel) + i
        if prepend_zero:
            mo.accel = np.hstack([0, self.accel[i_left:i_right]])
        else:
            mo.accel = self.accel[i_left:i_right]
        mo.generate_spectrum()
        print(
            f&#39;Motion is trimmed from {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
        if log:
            log_folder = self.folder if log_folder is None else log_folder
            os.makedirs(log_folder, exist_ok=True)
            _, ax = plt.subplots(3, 1, figsize=(7, 5))
            ax[0].plot(self.get_times(), self.accel, label=&#39;before&#39;)
            ax[1].plot(mo.get_times(), mo.accel, label=&#39;after&#39;)
            ax[2].plot(self.spectrum.periods, self.spectrum.spectrum, label=&#39;before&#39;)
            ax[2].plot(mo.spectrum.periods, mo.spectrum.spectrum, label=&#39;after&#39;)
            for i in range(3):
                ax[i].legend()
            plt.suptitle(f&#39;Trim log: {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
            plt.savefig(f&#39;{log_folder}/{mo.name}_trimlog.png&#39;, dpi=200)
        return mo

    def change_dt(self, dt, new_name, new_folder=None, log=True, log_folder=None):
        &#39;&#39;&#39;Change dt for the accel. Linearly interpolate the acceleration, and re-sample.
        Note: no low-pass filters are used. May cause new peaks in the Fourier spectrum.  

        Parameters
        ----------
        `dt` : float  
            New sampling delta t. 

        `new_name` : str  

        `new_folder` : str, None  

        `log` : boolean  
            If log, create a log picture comparing the before and after accels and spectrum.

        `log_folder` : str, None  
            Path for the folder to save the trim logs.
            If None, save in the previous folder.

        Returns
        -------
        `motion` : `Motion`  

        Outputs
        -------
        If log, create a picture named &#39;{log_folder}/{new_name}_dtlog.png&#39;.
        &#39;&#39;&#39;
        if dt == self.dt:
            print(f&#39;Motion {self.name} do not need to change dt&#39;)
            return self.copy()
        else:
            mo = self.copy()
            mo.name = new_name
            mo.folder = new_folder if new_folder is not None else self.folder
            f = interp1d(self.get_times(), self.accel)
            npts = np.floor(self.dt * len(self.accel) / dt)
            mo.accel = f(np.arange(npts)*dt)
            mo.dt = dt
            mo.generate_spectrum()
            print(f&#39;Motion dt changed from {self.name}:{self.dt:.4f}s to {mo.name}:{dt:.4f}s.&#39;)
        if log:
            log_folder = self.folder if log_folder is None else log_folder
            os.makedirs(log_folder, exist_ok=True)
            _, ax = plt.subplots(3, 1, figsize=(7, 5))
            ax[0].plot(self.get_times(), self.accel, label=&#39;before&#39;)
            ax[1].plot(mo.get_times(), mo.accel, label=&#39;after&#39;)
            ax[2].plot(self.spectrum.periods, self.spectrum.spectrum, label=&#39;before&#39;)
            ax[2].plot(mo.spectrum.periods, mo.spectrum.spectrum, label=&#39;after&#39;)
            for i in range(3):
                ax[i].legend()
            plt.suptitle(f&#39;Change dt: {self.name}:{self.dt:.4f}s to {mo.name}:{dt:.4f}s.&#39;)
            plt.savefig(f&#39;{log_folder}/{mo.name}_dtlog.png&#39;, dpi=200)
        return mo

    def truncate(self, time, new_name, new_folder=None, log=True, log_folder=None):
        &#39;&#39;&#39;Truncate the acceleration. 
        Sometimes, a ground motion file may have two peaks or more. 
        So if only one peak is needed, this method can be used to skip the other peaks.  

        Parameters
        ----------
        `time` : float
            The accels after the time will be cut off.  

        `new_name` : str

        `new_folder` : str, None  

        `log` : boolean  

        `log_folder` : str, None  

        Returns
        -------
        `motion` : `Motion`

        Outputs
        -------
        If log is True, a figure named &#39;{log_folder}/{new_name}_trunclog.png&#39; will be created.
        &#39;&#39;&#39;
        i = round(time / self.dt)
        mo = self.copy()
        mo.name = new_name
        mo.folder = new_folder if new_folder is not None else self.folder
        if i &gt;= len(self.accel):
            print(f&#34;WARNING: time is longer than duration. {self.name} is not truncated.&#34;)
            return mo
        mo.accel = self.accel[:i]
        mo.generate_spectrum()
        print(f&#39;Motion truncated: {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
        if log:
            log_folder = self.folder if log_folder is None else log_folder
            os.makedirs(log_folder, exist_ok=True)
            _, ax = plt.subplots(3, 1, figsize=(7, 5))
            ax[0].plot(self.get_times(), self.accel, label=&#39;before&#39;)
            ax[1].plot(mo.get_times(), mo.accel, label=&#39;after&#39;)
            ax[2].plot(self.spectrum.periods, self.spectrum.spectrum, label=&#39;before&#39;)
            ax[2].plot(mo.spectrum.periods, mo.spectrum.spectrum, label=&#39;after&#39;)
            for i in range(3):
                ax[i].legend()
            plt.suptitle(f&#39;Truncate: {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
            plt.savefig(f&#39;{log_folder}/{mo.name}_trunclog.png&#39;, dpi=200)
        return mo

    def scale(self, new_name, new_folder=None, factor_x=1, factor_y=1):
        &#39;&#39;&#39;Scale the ground motion.  

        Parameters
        ----------
        `new_name` : str

        `new_folder` : str, None

        `factor_x` : float  
            The scaling factor on the time/period axis.  

        `factor_y` : float
            The scaling factor on the accel axis.

        Returns
        -------
        `motion` : Motion
        &#39;&#39;&#39;
        mo = self.copy()
        mo.name = new_name
        mo.folder = new_folder if new_folder is not None else self.folder
        if factor_x != 1:
            mo.dt = self.dt * factor_x
        if factor_y != 1:
            mo.accel = self.accel * factor_y
        mo.spectrum = self.spectrum.scale(factor_x, factor_y)
        return mo

    def plot_timehistory(self, folder=None, save=True, engine=&#39;pyplot&#39;):
        &#39;&#39;&#39;Plot the time history of the acceleration.

        Parameters
        ----------
        `folder` : str, None  
            Store folder. If None, use `Motion.folder` 

        `save` : boolean
            Save the figure or not. 

        `engine` : &#39;pyplot&#39; or &#39;plotly&#39;  

        Outputs
        -------
        if save is True, create a figure &#39;{folder}/{self.name}_th&#39;.
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        if engine == &#39;pyplot&#39;:
            plt.figure()
            t = self.get_times()
            plt.plot(t, self.accel)
            if save:
                plt.savefig(f&#39;{folder}/{self.name}_th.png&#39;, dpi=200)
            else:
                plt.show()
        elif engine == &#39;plotly&#39;:
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=self.get_times(),
                y=self.accel,
                mode=&#39;lines&#39;,
                name=self.name
            ))
            if save:
                fig.write_html(f&#39;{folder}/{self.name}_th.html&#39;)
            else:
                fig.show()
        else:
            print(&#39;ERROR: engine should be in &#34;pyplot&#34; or &#34;plotly&#34;&#39;)

    def plot(self, folder=None, save=True, engine=&#39;pyplot&#39;):
        &#39;&#39;&#39;Plot the time history and the spectrum.

        Parameters
        ----------
        See `Motion.plot_timehistory`

        Outputs
        -------
        Create a figure named &#39;{folder}/{name}&#39;
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        if engine == &#39;pyplot&#39;:
            _, ax = plt.subplots(2, 1, figsize=(7, 8))
            ax[0].plot(self.get_times(), self.accel)
            ax[0].set_xlabel(&#39;Time(s)&#39;)
            ax[0].set_ylabel(&#39;Acceleration(g)&#39;)
            ax[0].set_title(f&#39;PGA={self.get_PGA():.4f}&#39;)
            ax[1].plot(self.spectrum.periods, self.spectrum.spectrum)
            ax[1].set_xlabel(&#39;Period(s)&#39;)
            ax[1].set_ylabel(&#39;Spectrum Acceleration(g)&#39;)
            ax[1].set_title(f&#39;damping={self.damping:.4f}&#39;)
            plt.subplots_adjust(hspace=0.3)
            if save:
                plt.savefig(f&#39;{folder}/{self.name}.png&#39;, dpi=200)
            else:
                plt.show()
        elif engine == &#39;plotly&#39;:
            fig = make_subplots(rows=1, cols=2)
            fig.add_trace(go.Scatter(
                x=self.get_times(),
                y=self.accel,
                mode=&#39;lines&#39;,
                name=&#39;accel&#39;
            ), row=1, col=2)
            fig.add_trace(go.Scatter(
                x=self.spectrum.periods,
                y=self.spectrum.spectrum,
                mode=&#39;lines&#39;,
                name=&#39;spectrum&#39;
            ), row=1, col=1)
            if save:
                fig.write_html(f&#39;{folder}/{self.name}.html&#39;)
            else:
                fig.show()
        else:
            print(&#39;Engine should be in &#34;pyplot&#34; or &#34;plotly&#34;&#39;)

    def write_accel(self, filename, time=True):
        &#39;&#39;&#39;Write the acceleration timehistory to a single file.  

        Parameters
        ----------
        `filename` : str  
            The file path to store the accelration.  

        `time` : boolean  
            If True, a time column is created.
            To know dt in the file content, time should be True.
            Otherwise, dt should be stored in the filename.

        Outputs
        -------
        An text file with acceleration information will be written.
        &#39;&#39;&#39;
        if time:
            data = np.vstack([self.get_times(), self.accel])
            np.savetxt(filename, data.T, fmt=&#34;%.4f,%.7e&#34;, header=&#34;Time,Accel&#34;)
        else:
            np.savetxt(filename, self.accel, fmt=&#34;%.7e&#34;)

    def write_info(self, filename):
        &#39;&#39;&#39;Write the information to a single file.  

        Parameters
        ----------
        `filename` : str

        Outputs
        -------
        A text file with information will be created.
        &#39;&#39;&#39;
        with open(filename, &#39;w&#39;) as f:
            f.write(f&#39;dt={self.dt:.3}\n&#39;)
            f.write(f&#39;npts={len(self.accel)}\n&#39;)
            f.write(f&#39;damping={self.damping:.3}\n&#39;)
            f.write(self.information)

    def write_spectrum(self, filename):
        &#39;&#39;&#39;Write the spectrum to a single file. Use the form of csv.

        Parameters
        ----------
        `filename` : str

        Outputs
        -------
        A csv file will be created.
        &#39;&#39;&#39;
        self.spectrum.write_csv(filename)

    def read_accel(self, filename, dt=True):
        &#39;&#39;&#39;Load an single-column acceleration file to the current instance.

        Parameters
        ----------
        `dt` : float, boolean
            if dt is float, `Motion.dt` will be set to dt.
            Else if dt is True, `Motion.dt` will be found in the file.

        Outputs
        -------
        Change `Motion.dt` and `Motion.accel` in the CURRENT instance.
        &#39;&#39;&#39;
        if not isinstance(dt, float):
            data = np.loadtxt(filename)
            self.accel = data[:, 1]
            self.dt = data[1, 0]
        else:
            self.accel = np.loadtxt(filename)
            self.dt = dt

    def read_spectrum(self, filename):
        &#39;&#39;&#39;Read the spectrum from csv file.  

        Parameters
        ----------
        `filename` : str

        Outputs
        -------
        The `Motion.spectrum` of the CURRENT instance will be changed.
        &#39;&#39;&#39;
        spectrum = Spectrum.read_csv(filename)
        self.spectrum = spectrum

    def read_info(self, filename):
        &#39;&#39;&#39;Read info from text file.  

        Parameters
        ----------
        `filename` : str

        Outputs
        -------
        The `Motion.information` of the CURRENT instance will be changed.
        &#39;&#39;&#39;
        with open(filename, &#39;r&#39;) as f:
            self.dt = float(f.readline().replace(&#34;dt=&#34;, &#34;&#34;))
            _ = int(f.readline().replace(&#34;npts=&#34;, &#34;&#34;))
            self.damping = float(f.readline().replace(&#34;damping=&#34;, &#34;&#34;))
            self.information = f.read()

    def to_dict(self):
        &#39;&#39;&#39;Convert the instance properties to dict.  

        Returns
        -------
        `it` : dict
        &#39;&#39;&#39;
        return dict(
            dt=self.dt,
            npts=len(self.accel),
            damping=self.damping,
            information=self.information,
            accel=self.accel.tolist(),
            spectrum=self.spectrum.to_dict(),
            folder=self.folder,
            name=self.name,
        )

    def to_json(self):
        &#39;&#39;&#39;Convert the instance properties to string using json format.  

        Returns
        -------
        `string` : str
        &#39;&#39;&#39;
        return json.dumps(self.to_dict())

    def save(self):
        &#39;&#39;&#39;Save the instance to a file, which is defined by `Motion.folder` and `Motion.name`  

        Outputs
        -------
        A file named &#39;{self.folder}/{self.name}.motion&#39; will be created.
        &#39;&#39;&#39;
        with open(f&#39;{self.folder}/{self.name}.motion&#39;, &#39;w&#39;) as f:
            f.write(self.to_json())

    @staticmethod
    def read_dict(it):
        &#39;&#39;&#39;Create a instance by the dict generated by `Motion.to_dict`.  

        Parameters
        ----------
        `it` : dict

        Returns
        -------
        `mo` : `Motion`
        &#39;&#39;&#39;
        mo = Motion(folder=it[&#39;folder&#39;], name=it[&#39;name&#39;])
        mo.dt = it[&#39;dt&#39;]
        mo.damping = it[&#39;damping&#39;]
        mo.information = it[&#39;information&#39;]
        mo.accel = np.array(it[&#39;accel&#39;])
        mo.spectrum = Spectrum.read_dict(it[&#39;spectrum&#39;])
        return mo

    @staticmethod
    def read_json(string):
        &#39;&#39;&#39;Create a new instance by the string generated by `Motion.to_json`.  

        Parameters
        ----------
        `string` : str

        Returns
        -------
        `mo` : `Motion`
        &#39;&#39;&#39;
        it = json.loads(string)
        return Motion.read_dict(it)

    @staticmethod
    def load(filename):
        &#39;&#39;&#39;Load the file created from `Motion.save` method.  

        Parameters
        ----------
        `filename` : str

        Returns
        -------
        `mo` : `Motion`
        &#39;&#39;&#39;
        if not filename.endswith(&#39;.motion&#39;):
            filename += &#39;.motion&#39;
        with open(filename, &#39;r&#39;) as f:
            return Motion.read_json(f.read())

    def copy(self):
        &#39;&#39;&#39;Copy the instance.

        Returns
        -------
        `mo` : `Motion`
        &#39;&#39;&#39;
        return Motion.read_dict(self.to_dict())


class Suite(object):
    &#39;&#39;&#39;A class that contains mainly a series of `Motion` instances, 
    and corresponding series of factors, matching the suite of motions to the target `Spectrum`.  
    &#39;&#39;&#39;

    def __init__(self, folder, name, target_spectrum, period_bound):
        &#39;&#39;&#39;
        Parameters
        ----------
        `folder` : str  
            A path-like string for the suite.

        `name` : str
            A specific name for the suite. The instance will be saved in &#39;{folder}/{name}.suite&#39;  

        `target_spectrum` : `Spectrum`  
            The target spectrum of the suite.  

        `period_bound` : List&lt;float&gt; len=2  
            The matching period boundaries.
        &#39;&#39;&#39;
        self.folder = folder
        &#39;&#39;&#39;str. See `Suite`&#39;&#39;&#39;
        os.makedirs(folder, exist_ok=True)
        self.name = name
        &#39;&#39;&#39;str. See `Suite`&#39;&#39;&#39;
        self.motions = []
        &#39;&#39;&#39;List&lt;`Motion`&gt;. Store all the motions.&#39;&#39;&#39;
        self.factors = []
        &#39;&#39;&#39;List&lt;float&gt;. Store all the factors that should be applied to the motions.&#39;&#39;&#39;
        self.target_spectrum = target_spectrum
        &#39;&#39;&#39;`Spectrum`. See `Suite`&#39;&#39;&#39;
        self.period_bound = period_bound
        &#39;&#39;&#39;List&lt;float&gt;. See `Suite`&#39;&#39;&#39;
        self.period_samples = np.linspace(period_bound[0], period_bound[1], 200)
        &#39;&#39;&#39;numpy.ndarray. The period within the `period_bound` is evenly sampled, with 200 points.&#39;&#39;&#39;
        self.spectrum_matrix = None
        &#39;&#39;&#39;numpy.ndarray. A matrix with shape (len(`Suite.period_samples`), len(`Suite.motions`)).
        This matrix times the `Suite.factors` vector products the average spectrum with `Suite.period_samples`.&#39;&#39;&#39;
        self.target_vector = target_spectrum.get(self.period_samples)
        &#39;&#39;&#39;numpy.ndarray. The vector generated by the target_spectrum sampling the `Suite.period_samples`&#39;&#39;&#39;

    def set_folder(self, folder):
        &#39;&#39;&#39;Reset the folder for the suite and the motions.

        Parameters
        ----------
        `folder` : str

        Outputs
        -------
        `Suite.folder` and `Suite.motions` will be changed.
        &#39;&#39;&#39;
        if folder is not None:
            self.folder = folder
            os.makedirs(folder, exist_ok=True)
            for mo in self.motions:
                mo.folder = folder

    def add_motion(self, motion, factor=1):
        &#39;&#39;&#39;Add motion to the suite together with a factor, to keep the lengths are identical.

        Parameters
        ----------
        `motion` : `Motion`

        `factor` : number

        Outputs
        -------
        `Suite.motions` and `Suite.factors` will be changed.
        &#39;&#39;&#39;
        self.motions.append(motion)
        self.factors.append(factor)

    def load_motions_from_names(self, names, folder=None):
        &#39;&#39;&#39;Give a list of name and the folder, load motions.

        Parameters
        ----------
        `names` : List&lt;str&gt;  
            The list of motion names.

        `folder` : str, None  
            The folder of the motions.  
            If is None, use `Suite.folder`

        Outputs
        -------
        `Suite.motions` and `Suite.factors` will be changed.
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        for name in names:
            mo = Motion.load(f&#39;{folder}/{name}.motion&#39;)
            self.add_motion(mo)
            print(f&#39;Loaded motion {mo.name}&#39;)
        self.reset_spectrum_matrix()

    def load_motions_from_folder(self, folder=None):
        &#39;&#39;&#39;Find all the .motion file from the given folder, and load them.  

        Parameters
        ----------
        `folder` : str, None   
            The folder to search the .motion files.  
            If is None, use `Suite.folder` instead.  

        Outputs
        -------
        `Suite.motions` and `Suite.factors` will be changed.
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        filenames = os.listdir(self.folder)
        for filename in filenames:
            if filename.endswith(&#39;.motion&#39;):
                mo = Motion.load(f&#39;{folder}/{filename}&#39;)
                self.add_motion(mo)
                print(f&#39;Loadad motion {mo.name}&#39;)
        self.reset_spectrum_matrix()

    def filter_by_IDs(self, ids, new_name, new_folder=None):
        &#39;&#39;&#39;Give a series of selected IDs, filter the motions.  

        Parameters
        ----------
        `ids` : List&lt;int&gt;  
            The list of indexes of the selected motions in the current suite.  

        `new_name` : str  

        `new_folder` : str, None

        Returns
        -------
        `suite` : `Suite`  
            A new suite with the selected motions and their factors only.  
        &#39;&#39;&#39;
        suite = self.copy()
        suite.name = new_name
        suite.set_folder(new_folder)
        suite.motions = [self.motions[i] for i in ids]
        suite.factors = [self.factors[i] for i in ids]
        suite.reset_spectrum_matrix()
        print(f&#39;The motions have been filtered. {len(ids)} motions remain.&#39;)
        return suite

    def filter_by_file(self, filename, new_name, new_folder=None):
        &#39;&#39;&#39;Give a file with indexes selected.  

        Parameters
        ----------
        Refer to `Suite.filter_by_IDs`.  

        Returns
        -------
        Refer to `Suite.filter_by_IDs`.  
        &#39;&#39;&#39;
        with open(filename, &#39;r&#39;) as f:
            lines = f.readlines()
        ids = [int(l) for l in lines]
        return self.filter_by_IDs(ids=ids, new_name=new_name, new_folder=new_folder)

    def get_average_spectrum(self):
        &#39;&#39;&#39;Return a spectrum which is the average spectrum of the suite.

        Outputs
        -------
        `spectrum` : `Spectrum`  
        &#39;&#39;&#39;
        periods = self.motions[0].spectrum.periods
        average_spectrum = self.motions[0].spectrum.spectrum * self.factors[0]
        for i in range(1, len(self.motions)):
            average_spectrum += self.motions[i].spectrum.get(periods) * self.factors[i]
        average_spectrum /= len(self.motions)
        return Spectrum(periods, average_spectrum)

    def get_srss(self):
        &#39;&#39;&#39;Get the srss of the current averate spectrum to the target spectrum in the period boundary.

        Returns
        -------
        `srss` : float
        &#39;&#39;&#39;
        return np.linalg.norm(np.matmul(self.spectrum_matrix, self.factors) - self.target_vector).item()

    def reset_spectrum_matrix(self):
        &#39;&#39;&#39;Reset the spectrum matrix, which produces the average spectrum 
        in the boundary by multiplying factors vector.
        This method should be called everytime `Suite.motions` change.

        Outputs
        -------
        `Suite.spectrum_matrix` and `Suite.target_vector` will be changed.  
        &#39;&#39;&#39;
        mat = np.zeros((len(self.period_samples), len(self.motions)))
        for i in range(len(self.motions)):
            spectrum = self.motions[i].spectrum.get(self.period_samples)
            mat[:, i] = spectrum / len(self.motions)
        self.spectrum_matrix = mat
        self.target_vector = self.target_spectrum.get(self.period_samples)

    def eliminate_neg(self):
        &#39;&#39;&#39;Eliminate negative target vector by multiplying a factor for every individual.
        In other words, make the average spectrum above the target spectrum.

        Returns
        -------
        `factor` : float  
            The global factor that should be applied to each of the factors.  

        Outputs
        -------
        `Suite.factors` are all amplified by the returned `factor`.
        &#39;&#39;&#39;
        error = np.matmul(self.spectrum_matrix, self.factors) - self.target_vector
        argmin = np.argmin(error)
        factor = 1 / (1 + error[argmin] / self.target_vector[argmin])
        print(f&#39;Multiply {factor:.4} to eliminate negative spectrum.&#39;)
        self.factors = [self.factors[i] * factor for i in range(len(self.factors))]
        return factor

    def match_individual_LSQ(self):
        &#39;&#39;&#39;Use Least square method for each individual motion to match the spectrum.

        Returns
        -------
        `residuals` : numpy.ndarray  
            srss of each motion matched to the target spectrum.  

        Outputs
        -------
        `Suite.factors` are changed.
        &#39;&#39;&#39;
        residuals = np.zeros(len(self.motions))
        for i in range(len(self.motions)):
            this = self.spectrum_matrix[:, i] * len(self.motions)
            that = self.target_vector
            factor = np.dot(this, that) / np.dot(this, this)
            residual = np.linalg.norm(this * factor - that)
            self.factors[i] = factor
            residuals[i] = residual
        print(f&#34;Individual LSQ: Factor Max={np.max(self.factors):.4}, Residual Max={np.max(residuals):.4}&#34;)
        return residuals

    def filter_optimize(self, count, times, use_lsq=True, output_count=0, new_folder=None, lower_bound=0.6, upper_bound=1.4, dimension=100000):
        &#39;&#39;&#39;Use Monte Carlo simulation and Least Square method to optimize the suite.
        after running, a bunch of suites will be written to the new_folder.

        Parameters  
        ----------
        `count` : int  
            The number of motions in the resulting suite.  

        `times` : int  
            The number of times that MC simulation with dimension is run.  
            The total number of samples of MC simulation will be {times} * {dimension}.  

        `use_lsq` : boolean  
            Whether use LSQ optimizer to better optimize the suite.  

        `output_count` : int  
            The number of outputs. if 0, output all.  

        `new_folder` : str 
        `lower_bound`, `upper_bound` : float  
            For the purpose that the individual motions are not too far from the individually matched factors,
            the lower and upper boundaries of amplifying the individually matched factors are set.  
            This is only useful when `use_lsq` is set, to add boundaries to the LSQ optimizer.  

        `dimension` : int  
            Each time the Monte Carlo simulation is run, 
            means that {dimension} times of simulation have been done by using a matrix target.

        Returns
        -------
        List&lt;`Suite`&gt; with len=`output_count`.  
        The list is sorted. The best answer is the first result. However, visual check should be done.

        Outputs
        -------
        Every running after Monte Carlo simulation and LSQ optimization, the spectrum of the suite will be plotted.
        &#39;&#39;&#39;
        new_folder = new_folder if new_folder is not None else self.folder
        os.makedirs(new_folder, exist_ok=True)
        suites = []
        srsses = []
        for i in range(times):
            suite_new = self.filter_montecarlo(count=count, new_name=f&#39;mc{i:03d}&#39;, new_folder=new_folder)
            suites.append(suite_new)
            srsses.append(suite_new.get_srss())
            if use_lsq:
                suite_new2 = suite_new.optimize_LSQ(
                    new_name=f&#39;lsq{i:03d}&#39;, 
                    new_folder=new_folder, 
                    lower_bound=lower_bound, 
                    upper_bound=upper_bound
                )
                suites.append(suite_new2)
                srsses.append(suite_new2.get_srss())
        argsorted = np.argsort(np.array(srsses))
        results = [suites[i] for i in argsorted[:output_count]]
        for i, suite in enumerate(results):
            suite.name = f&#39;no{i}-{suite.name}&#39;
            suite.save()
            suite.plot_all_spectrums(engine=&#39;pyplot&#39;)
        return results

    def filter_montecarlo(self, count, new_name, new_folder=None, dimension=100000):
        &#39;&#39;&#39;Use Monte Carlo simulation to filter the suite to count numbers of motions.

        Parameters
        ---------- 
        Refer to `Suite.filter_optimize`.  

        Returns
        -------
        `suite` : `Suite`   
            The optimized result after {dimension} times of MC simulations.
        &#39;&#39;&#39;
        print(f&#39;Running Monte Carlo simulation, dimension={dimension}&#39;)
        self.match_individual_LSQ()
        factors = np.array(self.factors)
        xs = np.zeros((len(self.motions), dimension))
        for i in range(dimension):
            indexes = random.sample(range(len(self.motions)), count)
            xs[indexes, i] = factors[indexes]
        mul = np.matmul(self.spectrum_matrix * len(self.motions) / count, xs)
        loss = mul - self.target_vector.reshape(-1, 1)
        argmin = np.argmin(loss, axis=0)
        lossmin = np.min(loss, axis=0)
        target_at_lossmin = self.target_vector[argmin]
        amps = 1 / (lossmin / target_at_lossmin + 1)
        lossAmp = mul * amps - self.target_vector.reshape(-1, 1)
        srss = np.linalg.norm(lossAmp, axis=0)
        arg = np.argmin(srss)
        factors = xs[:, arg] * amps[arg]
        suvives = np.where(factors &gt; 1.0e-3)
        suite = self.copy()
        suite.name = new_name
        suite.set_folder(new_folder)
        suite.motions = [self.motions[i] for i in suvives[0]]
        suite.factors = [factors[i] for i in suvives[0]]
        suite.reset_spectrum_matrix()
        return suite

    def _loss(self, x):
        &#39;&#39;&#39;Utility function: calculate the loss for optimization.&#39;&#39;&#39;
        factors = x * np.array(self.factors)
        mul = np.matmul(self.spectrum_matrix, factors)
        loss = mul - self.target_vector
        argmin = np.argmin(loss)
        amp = 1 / (loss[argmin] / self.target_vector[argmin] + 1)
        return mul * amp - self.target_vector

    def optimize_LSQ(self, new_name, new_folder=None, lower_bound=0.6, upper_bound=1.4):
        &#39;&#39;&#39;Use Least Square method from scipy to optimize the factors.

        Parameters
        ----------
        Refer to `Suite.filter_optimize`.   

        Returns
        -------
        `suite` : `Suite`  
            Optimized suite.
        &#39;&#39;&#39;
        print(&#39;Running Bounded Least Square optimization ...&#39;)
        res = least_squares(self._loss,
                            np.ones(len(self.motions)),
                            bounds=(lower_bound, upper_bound),
                            verbose=0)
        factors = res.x * self.factors
        suite = self.copy()
        suite.name = new_name
        suite.set_folder(new_folder)
        suite.factors = factors.tolist()
        suite.eliminate_neg()
        return suite

    def load_peer_folder(self, peer_folder, h1=True, h2=True, v=False):
        &#39;&#39;&#39;From a folder load all the PEER motions into the suite.  
        Extract the downloaded peer zip file first.

        Parameters
        ----------
        `peer_folder` : str  
            The folder path of the extracted PEER data. Where `_SearchResults.csv` can be found.

        `h1`, `h2`, `v` : boolean  
            Whether load the three directional files or not.  

        Outputs
        -------
        `Suite.motions`, `Suite.factors` will be changed.  
        All the PEER motions will be saved in .motion format in the new folder.  
        &#39;&#39;&#39;
        with open(f&#39;{peer_folder}/_SearchResults.csv&#39;, &#34;r&#34;) as f:
            for _ in range(34):
                f.readline()
            i = 0
            positions = []
            if h1:
                positions.append(19)
            if h2:
                positions.append(20)
            if v:
                positions.append(21)
            line = f.readline()
            while line != &#39;\n&#39;:
                cells = line.split(&#39;,&#39;)
                for pos in positions:
                    filename = cells[pos].replace(&#39; &#39;, &#39;&#39;)
                    motion_name = filename.replace(&#39;.AT2&#39;, &#39;&#39;)
                    print(f&#39;Loading {motion_name}&#39;)
                    mo = Motion(folder=self.folder, name=motion_name)
                    mo.load_peer(peer_filename=f&#39;{peer_folder}/{filename}&#39;)
                    mo.generate_spectrum()
                    mo.save()
                    self.add_motion(mo)
                    i += 1
                line = f.readline()
        self.reset_spectrum_matrix()
        print(f&#34;Successfully loaded {i} earthquakes from peer folder {peer_folder} to {self.folder}.&#34;)
        return True

    def beautify(self, new_name, run_steps=[1,2,3,4], dt=0.01, new_folder=None, trunc_dict={}, left=1.0e-3, right=1.0e-3, prepend_zero=True):
        &#39;&#39;&#39;Beautify the suite in 4 steps:  

        1. truncate the motions, see `Motion.truncate`  
        2. trim the near-zero parts, see `Motion.trim` 
        3. change dt to uniform, see `Motion.change_dt`
        4. rename the motions to a series.  

        This procedure is always logged to the current folder.  

        Parameters
        ----------
        `new_name` : str  

        `run_steps` : List&lt;int&gt;  
            The step number to run. Users can select which one out of the 4 steps to run.
            The order will also follow this List.  

        `dt` : float  
            The uniform delta t.   

        `new_folder` : str  

        `trunc_dict` : dict  
            A dict that defines the `time` parameter in `Motion.truncate`  
            In the dict, keys are the indexes of the motions in the suite, values are the `time` values.

        `left`, `right` : float  
            The parameters of PGA to trim. Refer to `Motion.trim`.  

        Returns
        -------
        `suite` : `Suite`

        Outputs
        -------
        All the logs and the pre- and post- beautify average spectrum.
        &#39;&#39;&#39;
        suite = self.copy()
        spectrum_hist = suite.get_average_spectrum()
        suite.plot_all_spectrums(engine=&#39;pyplot&#39;)
        for i, motion in enumerate(self.motions):
            mo = motion.copy()
            mo.name = f&#39;{self.name}-{i}-b&#39;
            for step in run_steps:
                if step == 1:
                    if i in trunc_dict:
                        mo = mo.truncate(time=trunc_dict[i], new_name=mo.name+&#39;1&#39;)
                elif step == 2:
                    mo = mo.trim(new_name=mo.name+&#39;2&#39;, left=left, right=right)
                elif step == 3:
                    mo = mo.change_dt(dt=dt, new_name=mo.name+&#39;3&#39;)
                elif step == 4:
                    mo.name = f&#39;{i:02}&#39; if len(self.motions) &lt;= 100 else f&#39;{i:03}&#39;
                else:
                    print(f&#39;step={step} is not recognized and ignored.&#39;)
            suite.motions[i] = mo
        spectrum_new = suite.get_average_spectrum()
        plt.figure()
        plt.plot(spectrum_hist.periods, spectrum_hist.spectrum, label=&#39;before&#39;)
        plt.plot(spectrum_new.periods, spectrum_new.spectrum, label=&#39;after&#39;)
        plt.plot(suite.target_spectrum.periods, suite.target_spectrum.spectrum, label=&#39;target&#39;)
        plt.legend()
        plt.suptitle(f&#39;Beautify: {self.name} -&gt; {new_name}&#39;)
        plt.savefig(f&#39;{self.folder}/{self.name}-beautify.png&#39;, dpi=200)
        suite.name = new_name 
        if new_folder is not None:
            suite.set_folder(new_folder)
        return suite

    def scale(self, new_name, new_folder=None, factor_x=1, factor_y=1, scale_target_spectrum=True):
        &#39;&#39;&#39;Scale the motions both horizontally and vertically.  

        Parameters
        ----------
        `new_name` : str  

        `new_folder` : str, None  

        `factor_x`, `factor_y` : float  
            The factors to amplify in x axis and y axis.  

        `scale_target_spectrum` : boolean  
            Whether scale the target spectrum as well.

        Returns
        -------
        `suite` : `Suite`
        &#39;&#39;&#39;
        suite = self.copy()
        suite.name = new_name
        suite.set_folder(new_folder)
        for i, motion in enumerate(self.motions):
            suite.motions[i] = motion.scale(
                new_name=motion.name, factor_x=factor_x, factor_y=factor_y)
        if scale_target_spectrum:
            suite.target_spectrum = self.target_spectrum.scale(
                factor_x=factor_x, factor_y=factor_y)
        if factor_x != 1:
            suite.period_bound = [p * factor_x for p in self.period_bound]
            suite.period_samples = self.period_samples * factor_x
        suite.reset_spectrum_matrix()
        return suite

    def write_TCL(self, folder=None, filename=None):
        &#39;&#39;&#39;Write the suite to TCL forms for OpenSees.  
        Currently the TCL contains only one dict. 
        The keys of the dict is the motion names. Then the essential properties are stored.  
        At the same time, the accelerations for each motion is written to a text file.

        Parameters
        ----------
        `folder` : str, None  
            The folder to write the tcl files.
            If is None, use `Suite.folder`.

        `filename` :  str, None  
            The tcl file name. If is None, use `Suite.name`.

        Outputs
        -------
        A tcl file and a series of acceleration files.
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        filename = self.name if filename is None else filename.replace(
            &#39;.tcl&#39;, &#39;&#39;) + &#39;.tcl&#39;
        os.makedirs(folder, exist_ok=True)
        config = &#39;&#39;
        config += &#39;dict set motion keys {&#39;
        names = [mo.name for mo in self.motions]
        config += &#39; &#39;.join(names)
        config += &#39;}\n\n&#39;
        for i, mo in enumerate(self.motions):
            mo.write_accel(f&#39;{folder}/{mo.name}&#39;, time=False)
            config += f&#39;dict set motion {mo.name} path {folder}/{mo.name}\n&#39;
            config += f&#39;dict set motion {mo.name} npts {len(mo.accel)}\n&#39;
            config += f&#39;dict set motion {mo.name} dt {mo.dt:.4f}\n&#39;
            config += f&#39;dict set motion {mo.name} amp {self.factors[i]:.4f}\n\n&#39;
        with open(f&#39;{folder}/{filename}.tcl&#39;, &#39;w&#39;) as f:
            f.write(config)

    def plot_all_accels(self, folder=None, filename=None, save=True, engine=&#39;pyplot&#39;):
        &#39;&#39;&#39;Plot amplified accelograms to a single file.  

        Parameters
        ----------
        `folder` : str, None  
            If is None, use `Suite.folder`.

        `filename` : str, None  
            If is None, use `Suite.name` + &#39;_accel&#39;

        `save` : boolean  
            If True, save the file. Else, show immediately.  

        `engine` : &#39;pyplot&#39; or &#39;plotly&#39;  

        Outputs
        -------
        A figure is plotted.
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        if engine == &#39;plotly&#39;:
            filename = f&#39;{self.name}_accel.html&#39; if filename is None else filename + &#39;.html&#39;
            fig = go.Figure()
            for i, motion in enumerate(self.motions):
                fig.add_trace(go.Scatter(
                    x=np.arange(len(motion.accels)) * motion.dt,
                    y=motion.accels,
                    mode=&#39;lines&#39;,
                    name=str(i) + motion.name,
                    text=motion.name
                ))
            if save:
                fig.write_html(f&#39;{folder}/{filename}&#39;)
            else:
                fig.show()
        elif engine == &#39;pyplot&#39;:
            print(&#39;Pyplot is not supported.&#39;)
        else:
            print(&#39;ERROR: engine should be in &#34;pyplot&#34; and &#34;plotly&#34;&#39;)

    def plot_all_spectrums(self, folder=None, filename=None, save=True, engine=&#39;pyplot&#39;):
        &#39;&#39;&#39;Plot all amplified spectrums in one file.  

        Parameters
        ----------
        Refer to `Suite.plot_all_accels`. 

        The filename if is None will be `Suite.name` + &#39;_spectrum&#39;  

        Outputs
        -------
        A figure will be generated.
        &#39;&#39;&#39;
        if engine == &#39;plotly&#39;:
            folder = self.folder if folder is None else folder
            filename = f&#39;{self.name}_spectrum.html&#39; if filename is None else filename + &#39;.html&#39;
            fig = go.Figure()
            for i, motion in enumerate(self.motions):
                fig.add_trace(go.Scatter(
                    x=motion.spectrum.periods,
                    y=motion.spectrum.spectrum * self.factors[i],
                    mode=&#39;lines&#39;,
                    name=motion.name,
                    text=motion.name
                ))
            spectrum1 = self.target_spectrum
            spectrum2 = self.get_average_spectrum()
            fig.add_trace(go.Scatter(
                x=spectrum1.periods,
                y=spectrum1.spectrum,
                mode=&#39;lines&#39;,
                name=&#39;Target&#39;,
                text=&#39;Target&#39;,
                line=dict(width=5),
            ))
            fig.add_trace(go.Scatter(
                x=spectrum2.periods,
                y=spectrum2.spectrum,
                mode=&#39;lines&#39;,
                name=&#39;Average&#39;,
                text=&#39;Average&#39;,
                line=dict(width=5),
            ))
            if save:
                fig.write_html(f&#39;{folder}/{filename}&#39;)
            else:
                fig.show()
        elif engine == &#39;pyplot&#39;:
            folder = self.folder if folder is None else folder
            filename = f&#39;{self.name}_spectrum.png&#39; if filename is None else filename + &#39;.png&#39;
            plt.figure(figsize=(7, 5))
            for i, motion in enumerate(self.motions):
                plt.plot(motion.spectrum.periods, motion.spectrum.spectrum * self.factors[i], label=motion.name, c=&#39;silver&#39;)
            plt.plot(self.target_spectrum.periods, self.target_spectrum.spectrum, label=&#39;Target&#39;, linewidth=3)
            averageSpectrum = self.get_average_spectrum()
            plt.plot(averageSpectrum.periods, averageSpectrum.spectrum, label=&#34;average&#34;, linewidth=2)
            plt.legend(loc=&#39;best&#39;, fontsize=&#39;x-small&#39;)
            plt.title(f&#39;SRSS={self.get_srss():.4f}&#39;)
            if save:
                plt.savefig(os.path.join(folder, filename), dpi=200)
            else:
                plt.show()
        else:
            print(&#34;ERROR: wrong engine name. use &#39;plotly&#39; or &#39;pyplot&#39;.&#34;)

    def plot_individual(self, save=True):
        &#39;&#39;&#39;Plot all individual ground motions and the spectrum.

        Parameters
        ----------
        Refer to `Suite.plot_all_accels`.  

        Outputs
        -------
        If save, a figure for each motion will be generated.  
        &#39;&#39;&#39;
        for i, mo in enumerate(self.motions):
            _, ax = plt.subplots(2, 1, figsize=(7, 5))
            ax[0].plot(np.arange(len(mo.accel)) * mo.dt,
                        mo.accel * self.factors[i])
            ax[1].plot(mo.spectrum.periods,
                        mo.spectrum.spectrum * self.factors[i])
            ax[1].plot(self.target_spectrum.periods,
                        self.target_spectrum.spectrum, linewidth=2)
            plt.suptitle(
                f&#39;{i}: Name {mo.name}\nfactor={self.factors[i]:.4}, PGA={mo.get_PGA()*self.factors[i]:.4}, dt={mo.dt:.3f}&#39;)
            filename = f&#39;{self.folder}/motion{i}.png&#39;
            if save:
                plt.savefig(filename, dpi=200)
            else:
                plt.show()

    def plot_interactive(self, save=True):
        &#39;&#39;&#39;Plot the spectrum and the acceleration time-histories to an interactive html file.
        
        Parameters
        ----------
        `save` : boolean  
            If True, write to html file. Otherwise, show directly without saving.  
        
        Outputs
        -------
        A html file with interactive plotting sliders.
        &#39;&#39;&#39;
        fig = make_subplots(rows=1, cols=2)
        for i in range(len(self.motions)):
            fig.add_trace(go.Scatter(
                x=self.motions[i].spectrum.periods,
                y=self.motions[i].spectrum.spectrum * self.factors[i],
                name=self.motions[i].name,
            ), row=1, col=1)
            fig.add_trace(go.Scatter(
                x=self.motions[i].get_times(),
                y=self.motions[i].accel * self.factors[i],
                    name=self.motions[i].name,
            ), row=1, col=2)
        spectrum_average = self.get_average_spectrum()
        fig.add_trace(go.Scatter(
            x=spectrum_average.periods,
            y=spectrum_average.spectrum,
            name=&#39;average&#39;,
            line={&#39;width&#39;: 5}
        ))
        fig.add_trace(go.Scatter(
            x=self.target_spectrum.periods,
            y=self.target_spectrum.spectrum,
            name=&#39;target&#39;,
            line={&#39;width&#39;: 5}
        ))

        def _title(i):
            return f&#39;Motion #{i}: factor={self.factors[i]:.2f}, duration={len(self.motions[i].accel)*self.motions[i].dt:.2f}, PGA={self.motions[i].get_PGA()*self.factors[i]:.4}&#39;
        
        steps = []
        for i in range(len(self.motions)):
            step = dict(
                method=&#39;update&#39;,
                args=[
                    {&#39;visible&#39;: [j//2 == i for j in range(len(self.motions)*2)] + [False, True]},
                    {&#39;title&#39;: _title(i)}
                ],
                label=str(i),
            )
            steps.append(step)
        sliders = [dict(active=0, steps=steps, len=0.9, currentvalue={&#39;visible&#39;: False})]
        updatemenus = [dict(
            buttons=[dict(
                label=&#39;All&#39;,
                method=&#39;update&#39;,
                args=[
                    {&#39;visible&#39;: [True] * (len(self.motions)*2+2)},
                    {&#39;title&#39;: f&#39;Suite {self.name}: {len(self.motions)} motions, SRSS={self.get_srss():.4}&#39;}
                ]
            )],
            type=&#39;buttons&#39;,
            x=1,
            y=0,
            xanchor=&#39;right&#39;,
            yanchor=&#39;top&#39;,
            pad={&#39;t&#39;: 30},
        )]
        fig.update_layout(sliders=sliders, title=f&#39;Suite {self.name}: {len(self.motions)} motions, SRSS={self.get_srss():.4}&#39;, updatemenus=updatemenus)
        if save:
            fig.write_html(f&#39;{self.folder}/{self.name}.html&#39;)
        else:
            fig.show()
    
    def to_dict(self, separate_motion=True):
        &#39;&#39;&#39;Convert all the properties to dict.  

        Parameters
        ----------  
        `separate_motion` : boolean  
            If True, the motion details are not included into the dict.  
            User has to make sure these motions are not moved.

        Returns
        -------  
        `it` : dict  
        &#39;&#39;&#39;
        return dict(
            folder=self.folder,
            name=self.name,
            motions=[mo.to_dict() for mo in self.motions] if not separate_motion else [
                f&#39;{mo.folder}/{mo.name}&#39; for mo in self.motions],
            factors=self.factors if type(self.factors[0] == float) else [
                fact.item() for fact in self.factors],
            period_bound=self.period_bound,
            target_spectrum=self.target_spectrum.to_dict(),
            period_samples=self.period_samples.tolist(),
            srss=self.get_srss(),
            average_spectrum=self.get_average_spectrum().to_dict(),
        )

    def to_json(self, separate_motion=True):
        &#39;&#39;&#39;Convert the properties to json.  

        Parameters
        ----------
        Refer to `Suite.to_dict`.  

        Returns
        -------
        `json` : str
        &#39;&#39;&#39;
        return json.dumps(self.to_dict(separate_motion=separate_motion))

    def save(self, separate_motion=True, rewrite=False):
        &#39;&#39;&#39;Save the suite to a .suite file.  

        Parameters
        ----------  
        `separate_motion` : boolean  
            If True, the motion details are not included into the file.  
            User has to make sure the motions are not moved.

        `rewrite` : boolean   
            If True, all the &#39;.motion&#39; files will be rewritten.  
            otherwise, the motion files will be ignored.

        Outputs
        -------
        Create a .suite file to store the suite.
        &#39;&#39;&#39;
        with open(f&#39;{self.folder}/{self.name}.suite&#39;, &#39;w&#39;) as f:
            f.write(self.to_json(separate_motion=separate_motion))
        if separate_motion:
            for mo in self.motions:
                if not os.path.exists(f&#39;{mo.folder}/{mo.name}.motion&#39;):
                    mo.save()
                    print(f&#39;Motion saved to {mo.folder}/{mo.name}.motion&#39;)
                else:
                    if rewrite:
                        mo.save()
                        print(f&#39;Motion {mo.folder}/{mo.name}.motion is written.&#39;)
        print(f&#39;Saved to {self.folder}/{self.name}.suite&#39;)

    @staticmethod
    def read_dict(it):
        &#39;&#39;&#39;Read the dictionary representing the properties of the class.  
        If key &#39;motions&#39; is a instance of dict, then construct motions with dict.   
        else, key &#39;motions&#39; should be a list of {folder}/{name}, then construct with the .motion file.  

        Parameters
        ----------  
        `it` : dict  
            The dict generated by `Suite.to_dict`  

        Returns
        -------  
        `suite` : `Suite` 
        &#39;&#39;&#39;
        suite = Suite(
            folder=it[&#39;folder&#39;],
            name=it[&#39;name&#39;],
            target_spectrum=Spectrum.read_dict(it[&#39;target_spectrum&#39;]),
            period_bound=it[&#39;period_bound&#39;]
        )
        for i, mo_content in enumerate(it[&#39;motions&#39;]):
            if isinstance(mo_content, dict):
                suite.add_motion(Motion.read_dict(
                    mo_content), it[&#39;factors&#39;][i])
            else:
                suite.add_motion(Motion.load(
                    f&#39;{mo_content}.motion&#39;), it[&#39;factors&#39;][i])
        suite.period_samples = np.array(it[&#39;period_samples&#39;])
        suite.target_vector = suite.target_spectrum.get(suite.period_samples)
        suite.reset_spectrum_matrix()
        return suite

    @staticmethod
    def load(filename):
        &#39;&#39;&#39;Load a the suite from a file.  

        Parameters
        ----------
        `filename` : str  
            File that stores the suite.

        Returns
        -------
        `suite` : `Suite`
        &#39;&#39;&#39;
        if not filename.endswith(&#39;.suite&#39;):
            filename += &#39;.suite&#39;
        with open(filename, &#39;r&#39;) as f:
            return Suite.read_dict(json.loads(f.read()))

    def copy(self):
        &#39;&#39;&#39;Copy the instance.  
        Returns
        -------
        `suite` : `Suite`
        &#39;&#39;&#39;
        return Suite.read_dict(self.to_dict(separate_motion=False))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyearthquake.Motion"><code class="flex name class">
<span>class <span class="ident">Motion</span></span>
<span>(</span><span>folder, name, damping=0.05)</span>
</code></dt>
<dd>
<section class="desc"><p>A class plays with ground motion. Store accel time history and accel spectrum only.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>folder</code> : str <br>
the folder this motion is stored.</p>
<p><code>name</code> : str<br>
The motion name. The motion will be saved to '{folder}/{name}.motion'</p>
<p><code>damping</code> : float<br>
The damping ratio of the motion spectrum.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Motion(object):
    &#39;&#39;&#39;A class plays with ground motion. Store accel time history and accel spectrum only.  
    &#39;&#39;&#39;

    def __init__(self, folder, name, damping=0.05):
        &#39;&#39;&#39;
        Parameters
        ----------
        `folder` : str   
            the folder this motion is stored.

        `name` : str  
            The motion name. The motion will be saved to &#39;{folder}/{name}.motion&#39;

        `damping` : float  
            The damping ratio of the motion spectrum.  
        &#39;&#39;&#39;
        self.folder = folder
        &#39;&#39;&#39;str. See `Motion`.&#39;&#39;&#39;
        os.makedirs(folder, exist_ok=True)
        self.name = name
        &#39;&#39;&#39;str. See `Motion`.&#39;&#39;&#39;
        self.accel = None
        &#39;&#39;&#39;numpy.ndarray. Acceleration time history with evenly distributed sampling points.&#39;&#39;&#39;
        self.dt = None
        &#39;&#39;&#39;float. Acceleration time sampling delta t.&#39;&#39;&#39;
        self.information = &#39;&#39;
        &#39;&#39;&#39;str. Store massive infomation about the motion. &#39;&#39;&#39;
        self.spectrum = None
        &#39;&#39;&#39;`Spectrum`. The spectrum of the motion.&#39;&#39;&#39;
        self.damping = damping
        &#39;&#39;&#39;float. The damping ratio of the spectrum. Note: init with 0.05.&#39;&#39;&#39;

    def get_PGA(self):
        &#39;&#39;&#39;
        Returns
        -------
        `value` : float  
            The peak ground acceleration.  
        &#39;&#39;&#39;
        return np.max(abs(self.accel))

    def get_duration(self):
        &#39;&#39;&#39;
        Returns
        -------
        `value` : float  
            The duration of the motion.  
        &#39;&#39;&#39;
        return (len(self.accel) - 1) * self.dt

    def get_times(self):
        &#39;&#39;&#39;
        Returns
        -------
        `value` : numpy.ndarray  
            The time series of the motion  
        &#39;&#39;&#39;
        return np.arange(len(self.accel)) * self.dt

    def generate_spectrum(self, periods=None):
        &#39;&#39;&#39;Use scipy LTS signal processing module to generate the spectrum.  
        Note that the accel spectrum is pseudo-spectrum derived from disp spectrum.  
        So it&#39;s only accurate when damping is small.  
        If `Motion.dt` is still None, which usually occurs if the PEER file is not well formated, 
            a blank spectrum will be returned.  

        Parameters
        ----------
        `periods` : List-like, None    
            The period sampling points.   
            If is None, `Spectrum.periods_standard` will be called.

        Returns
        -------
        `spectrum` : `Spectrum`  
            The generated spectrum.

        Outputs
        -------
        `Motion.spectrum` will be changed.
        &#39;&#39;&#39;
        if periods is None:
            periods = Spectrum.periods_standard()
        if self.dt is not None:
            print(&#34;Generating spectrum ...&#34;)
            omegas = 2 * np.pi / periods[1:]
            num = np.array([-1])
            spectrum = np.zeros(len(periods))
            spectrum[0] = self.get_PGA()
            for i, omega in enumerate(omegas):
                den = np.array([1, 2*self.damping*omega, omega**2])
                _, y, _ = lsim((num, den), self.accel, self.get_times())
                spectrum[i+1] = np.max(abs(y)) * omega ** 2
            self.spectrum = Spectrum(periods, spectrum)
        else:
            print(&#34;Dt is not known. Assigning empty spectrum.&#34;)
            self.spectrum = Spectrum(periods=[], spectrum=[])
        return self.spectrum

    def load_peer(self, peer_filename):
        &#39;&#39;&#39;Load acceleration time-history files downloaded from PEER.  
        The strings in the file will be parsed and also stored in self.information.  

        Parameters
        ----------
        `peer_filename` : str

        Outputs
        -------
        `Motion.dt`, `Motion.accel`, `Motion.information`, `Motion.spectrum` will all be changed.  
        &#39;&#39;&#39;
        self.information += f&#39;peer_filename: {peer_filename}&#39;
        try:
            f = open(peer_filename, &#39;r&#39;)
            for _ in range(3):
                self.information += f.readline()
            s = f.readline()
            self.information += s
            re_dt = re.compile(r&#34;.*[ 0](\.[0-9]*) ?SEC&#34;)
            mt = re_dt.match(s)
            try:
                self.dt = float(mt.group(1).replace(&#39;.&#39;, &#39;0.&#39;))
                print(f&#39;Extracted dt = {self.dt:.4f}&#39;)
            except:
                print(f&#39;ERROR: cannot find dt from {s}&#39;)
                self.dt = 0.000001
            series = []
            datastring = f.readlines()
            for dtline in datastring:
                for dt in dtline.split(&#34;  &#34;):
                    if dt:
                        try:
                            series.append(float(dt.replace(&#34;.&#34;, &#34;0.&#34;)))
                        except ValueError:
                            break
            self.accel = np.array(series)
            print(f&#39;Extracted npts = {len(self.accel)}&#39;)
        except IOError:
            print(f&#39;No file named {self.name} is found.&#39;)

    def convert_peer(self, peer_filename):
        &#39;&#39;&#39;A recipe to convert the peer acceleration file to the .motion file.  

        Parameters
        ----------
        `peer_filename` : str  

        `folder` : str  
            the folder to save .motion file.

        Outputs
        -------
        A .motion file will be created in `folder` with the PEER filename.
        &#39;&#39;&#39;
        print(f&#39;Converting PEER file {peer_filename} to folder {self.folder} with name {self.name}&#39;)
        self.load_peer(peer_filename)
        self.generate_spectrum()
        self.save()

    def trim(self, new_name, new_folder=None, left=1.0e-3, right=1.0e-3, prepend_zero=True, log=True, log_folder=None):
        &#39;&#39;&#39;Trim the motion with two coefficients of PGA.  
        This method is used when a long near-zero time-history is stored in the data file.  

        Parameters
        ----------
        `new_name` : str  

        `new_folder` : str, None  

        `left`, `right` : float 
            The coefficient of PGA to trim the time history.
            Search from left or right, when the target point is found,
            search for the nearest near-zero point. Then trim off the small values.  


        `prepend_zero` : boolean  
            If True, prepend a zero value to the trimmed acceleration.

        `log` : boolean  
            If the log picture will be generated.

        `log_folder` : str, None
            Path for the folder to save the trim logs.
            If None, save in the previous folder.

        Returns
        -------
        `motion` : `Motion`  
            The trimmed motion.

        Outputs
        -------
        If log, plot a figure in log_folder named &#39;{new_name}_trimlog.png&#39;
        &#39;&#39;&#39;
        mo = self.copy()
        mo.name = new_name
        mo.folder = new_folder if new_folder is not None else self.folder
        pga = self.get_PGA()
        # search left
        i = 0
        while abs(self.accel[i]) &lt; pga * left:
            i += 1
        while i &gt; 0 and self.accel[i] * self.accel[i-1] &gt; 0:
            i -= 1
        i_left = i
        # search right
        i = -1
        while abs(self.accel[i]) &lt; pga * right:
            i -= 1
        while i &lt; -1 and self.accel[i] * self.accel[i+1] &gt; 0:
            i += 1
        i_right = len(self.accel) + i
        if prepend_zero:
            mo.accel = np.hstack([0, self.accel[i_left:i_right]])
        else:
            mo.accel = self.accel[i_left:i_right]
        mo.generate_spectrum()
        print(
            f&#39;Motion is trimmed from {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
        if log:
            log_folder = self.folder if log_folder is None else log_folder
            os.makedirs(log_folder, exist_ok=True)
            _, ax = plt.subplots(3, 1, figsize=(7, 5))
            ax[0].plot(self.get_times(), self.accel, label=&#39;before&#39;)
            ax[1].plot(mo.get_times(), mo.accel, label=&#39;after&#39;)
            ax[2].plot(self.spectrum.periods, self.spectrum.spectrum, label=&#39;before&#39;)
            ax[2].plot(mo.spectrum.periods, mo.spectrum.spectrum, label=&#39;after&#39;)
            for i in range(3):
                ax[i].legend()
            plt.suptitle(f&#39;Trim log: {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
            plt.savefig(f&#39;{log_folder}/{mo.name}_trimlog.png&#39;, dpi=200)
        return mo

    def change_dt(self, dt, new_name, new_folder=None, log=True, log_folder=None):
        &#39;&#39;&#39;Change dt for the accel. Linearly interpolate the acceleration, and re-sample.
        Note: no low-pass filters are used. May cause new peaks in the Fourier spectrum.  

        Parameters
        ----------
        `dt` : float  
            New sampling delta t. 

        `new_name` : str  

        `new_folder` : str, None  

        `log` : boolean  
            If log, create a log picture comparing the before and after accels and spectrum.

        `log_folder` : str, None  
            Path for the folder to save the trim logs.
            If None, save in the previous folder.

        Returns
        -------
        `motion` : `Motion`  

        Outputs
        -------
        If log, create a picture named &#39;{log_folder}/{new_name}_dtlog.png&#39;.
        &#39;&#39;&#39;
        if dt == self.dt:
            print(f&#39;Motion {self.name} do not need to change dt&#39;)
            return self.copy()
        else:
            mo = self.copy()
            mo.name = new_name
            mo.folder = new_folder if new_folder is not None else self.folder
            f = interp1d(self.get_times(), self.accel)
            npts = np.floor(self.dt * len(self.accel) / dt)
            mo.accel = f(np.arange(npts)*dt)
            mo.dt = dt
            mo.generate_spectrum()
            print(f&#39;Motion dt changed from {self.name}:{self.dt:.4f}s to {mo.name}:{dt:.4f}s.&#39;)
        if log:
            log_folder = self.folder if log_folder is None else log_folder
            os.makedirs(log_folder, exist_ok=True)
            _, ax = plt.subplots(3, 1, figsize=(7, 5))
            ax[0].plot(self.get_times(), self.accel, label=&#39;before&#39;)
            ax[1].plot(mo.get_times(), mo.accel, label=&#39;after&#39;)
            ax[2].plot(self.spectrum.periods, self.spectrum.spectrum, label=&#39;before&#39;)
            ax[2].plot(mo.spectrum.periods, mo.spectrum.spectrum, label=&#39;after&#39;)
            for i in range(3):
                ax[i].legend()
            plt.suptitle(f&#39;Change dt: {self.name}:{self.dt:.4f}s to {mo.name}:{dt:.4f}s.&#39;)
            plt.savefig(f&#39;{log_folder}/{mo.name}_dtlog.png&#39;, dpi=200)
        return mo

    def truncate(self, time, new_name, new_folder=None, log=True, log_folder=None):
        &#39;&#39;&#39;Truncate the acceleration. 
        Sometimes, a ground motion file may have two peaks or more. 
        So if only one peak is needed, this method can be used to skip the other peaks.  

        Parameters
        ----------
        `time` : float
            The accels after the time will be cut off.  

        `new_name` : str

        `new_folder` : str, None  

        `log` : boolean  

        `log_folder` : str, None  

        Returns
        -------
        `motion` : `Motion`

        Outputs
        -------
        If log is True, a figure named &#39;{log_folder}/{new_name}_trunclog.png&#39; will be created.
        &#39;&#39;&#39;
        i = round(time / self.dt)
        mo = self.copy()
        mo.name = new_name
        mo.folder = new_folder if new_folder is not None else self.folder
        if i &gt;= len(self.accel):
            print(f&#34;WARNING: time is longer than duration. {self.name} is not truncated.&#34;)
            return mo
        mo.accel = self.accel[:i]
        mo.generate_spectrum()
        print(f&#39;Motion truncated: {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
        if log:
            log_folder = self.folder if log_folder is None else log_folder
            os.makedirs(log_folder, exist_ok=True)
            _, ax = plt.subplots(3, 1, figsize=(7, 5))
            ax[0].plot(self.get_times(), self.accel, label=&#39;before&#39;)
            ax[1].plot(mo.get_times(), mo.accel, label=&#39;after&#39;)
            ax[2].plot(self.spectrum.periods, self.spectrum.spectrum, label=&#39;before&#39;)
            ax[2].plot(mo.spectrum.periods, mo.spectrum.spectrum, label=&#39;after&#39;)
            for i in range(3):
                ax[i].legend()
            plt.suptitle(f&#39;Truncate: {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
            plt.savefig(f&#39;{log_folder}/{mo.name}_trunclog.png&#39;, dpi=200)
        return mo

    def scale(self, new_name, new_folder=None, factor_x=1, factor_y=1):
        &#39;&#39;&#39;Scale the ground motion.  

        Parameters
        ----------
        `new_name` : str

        `new_folder` : str, None

        `factor_x` : float  
            The scaling factor on the time/period axis.  

        `factor_y` : float
            The scaling factor on the accel axis.

        Returns
        -------
        `motion` : Motion
        &#39;&#39;&#39;
        mo = self.copy()
        mo.name = new_name
        mo.folder = new_folder if new_folder is not None else self.folder
        if factor_x != 1:
            mo.dt = self.dt * factor_x
        if factor_y != 1:
            mo.accel = self.accel * factor_y
        mo.spectrum = self.spectrum.scale(factor_x, factor_y)
        return mo

    def plot_timehistory(self, folder=None, save=True, engine=&#39;pyplot&#39;):
        &#39;&#39;&#39;Plot the time history of the acceleration.

        Parameters
        ----------
        `folder` : str, None  
            Store folder. If None, use `Motion.folder` 

        `save` : boolean
            Save the figure or not. 

        `engine` : &#39;pyplot&#39; or &#39;plotly&#39;  

        Outputs
        -------
        if save is True, create a figure &#39;{folder}/{self.name}_th&#39;.
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        if engine == &#39;pyplot&#39;:
            plt.figure()
            t = self.get_times()
            plt.plot(t, self.accel)
            if save:
                plt.savefig(f&#39;{folder}/{self.name}_th.png&#39;, dpi=200)
            else:
                plt.show()
        elif engine == &#39;plotly&#39;:
            fig = go.Figure()
            fig.add_trace(go.Scatter(
                x=self.get_times(),
                y=self.accel,
                mode=&#39;lines&#39;,
                name=self.name
            ))
            if save:
                fig.write_html(f&#39;{folder}/{self.name}_th.html&#39;)
            else:
                fig.show()
        else:
            print(&#39;ERROR: engine should be in &#34;pyplot&#34; or &#34;plotly&#34;&#39;)

    def plot(self, folder=None, save=True, engine=&#39;pyplot&#39;):
        &#39;&#39;&#39;Plot the time history and the spectrum.

        Parameters
        ----------
        See `Motion.plot_timehistory`

        Outputs
        -------
        Create a figure named &#39;{folder}/{name}&#39;
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        if engine == &#39;pyplot&#39;:
            _, ax = plt.subplots(2, 1, figsize=(7, 8))
            ax[0].plot(self.get_times(), self.accel)
            ax[0].set_xlabel(&#39;Time(s)&#39;)
            ax[0].set_ylabel(&#39;Acceleration(g)&#39;)
            ax[0].set_title(f&#39;PGA={self.get_PGA():.4f}&#39;)
            ax[1].plot(self.spectrum.periods, self.spectrum.spectrum)
            ax[1].set_xlabel(&#39;Period(s)&#39;)
            ax[1].set_ylabel(&#39;Spectrum Acceleration(g)&#39;)
            ax[1].set_title(f&#39;damping={self.damping:.4f}&#39;)
            plt.subplots_adjust(hspace=0.3)
            if save:
                plt.savefig(f&#39;{folder}/{self.name}.png&#39;, dpi=200)
            else:
                plt.show()
        elif engine == &#39;plotly&#39;:
            fig = make_subplots(rows=1, cols=2)
            fig.add_trace(go.Scatter(
                x=self.get_times(),
                y=self.accel,
                mode=&#39;lines&#39;,
                name=&#39;accel&#39;
            ), row=1, col=2)
            fig.add_trace(go.Scatter(
                x=self.spectrum.periods,
                y=self.spectrum.spectrum,
                mode=&#39;lines&#39;,
                name=&#39;spectrum&#39;
            ), row=1, col=1)
            if save:
                fig.write_html(f&#39;{folder}/{self.name}.html&#39;)
            else:
                fig.show()
        else:
            print(&#39;Engine should be in &#34;pyplot&#34; or &#34;plotly&#34;&#39;)

    def write_accel(self, filename, time=True):
        &#39;&#39;&#39;Write the acceleration timehistory to a single file.  

        Parameters
        ----------
        `filename` : str  
            The file path to store the accelration.  

        `time` : boolean  
            If True, a time column is created.
            To know dt in the file content, time should be True.
            Otherwise, dt should be stored in the filename.

        Outputs
        -------
        An text file with acceleration information will be written.
        &#39;&#39;&#39;
        if time:
            data = np.vstack([self.get_times(), self.accel])
            np.savetxt(filename, data.T, fmt=&#34;%.4f,%.7e&#34;, header=&#34;Time,Accel&#34;)
        else:
            np.savetxt(filename, self.accel, fmt=&#34;%.7e&#34;)

    def write_info(self, filename):
        &#39;&#39;&#39;Write the information to a single file.  

        Parameters
        ----------
        `filename` : str

        Outputs
        -------
        A text file with information will be created.
        &#39;&#39;&#39;
        with open(filename, &#39;w&#39;) as f:
            f.write(f&#39;dt={self.dt:.3}\n&#39;)
            f.write(f&#39;npts={len(self.accel)}\n&#39;)
            f.write(f&#39;damping={self.damping:.3}\n&#39;)
            f.write(self.information)

    def write_spectrum(self, filename):
        &#39;&#39;&#39;Write the spectrum to a single file. Use the form of csv.

        Parameters
        ----------
        `filename` : str

        Outputs
        -------
        A csv file will be created.
        &#39;&#39;&#39;
        self.spectrum.write_csv(filename)

    def read_accel(self, filename, dt=True):
        &#39;&#39;&#39;Load an single-column acceleration file to the current instance.

        Parameters
        ----------
        `dt` : float, boolean
            if dt is float, `Motion.dt` will be set to dt.
            Else if dt is True, `Motion.dt` will be found in the file.

        Outputs
        -------
        Change `Motion.dt` and `Motion.accel` in the CURRENT instance.
        &#39;&#39;&#39;
        if not isinstance(dt, float):
            data = np.loadtxt(filename)
            self.accel = data[:, 1]
            self.dt = data[1, 0]
        else:
            self.accel = np.loadtxt(filename)
            self.dt = dt

    def read_spectrum(self, filename):
        &#39;&#39;&#39;Read the spectrum from csv file.  

        Parameters
        ----------
        `filename` : str

        Outputs
        -------
        The `Motion.spectrum` of the CURRENT instance will be changed.
        &#39;&#39;&#39;
        spectrum = Spectrum.read_csv(filename)
        self.spectrum = spectrum

    def read_info(self, filename):
        &#39;&#39;&#39;Read info from text file.  

        Parameters
        ----------
        `filename` : str

        Outputs
        -------
        The `Motion.information` of the CURRENT instance will be changed.
        &#39;&#39;&#39;
        with open(filename, &#39;r&#39;) as f:
            self.dt = float(f.readline().replace(&#34;dt=&#34;, &#34;&#34;))
            _ = int(f.readline().replace(&#34;npts=&#34;, &#34;&#34;))
            self.damping = float(f.readline().replace(&#34;damping=&#34;, &#34;&#34;))
            self.information = f.read()

    def to_dict(self):
        &#39;&#39;&#39;Convert the instance properties to dict.  

        Returns
        -------
        `it` : dict
        &#39;&#39;&#39;
        return dict(
            dt=self.dt,
            npts=len(self.accel),
            damping=self.damping,
            information=self.information,
            accel=self.accel.tolist(),
            spectrum=self.spectrum.to_dict(),
            folder=self.folder,
            name=self.name,
        )

    def to_json(self):
        &#39;&#39;&#39;Convert the instance properties to string using json format.  

        Returns
        -------
        `string` : str
        &#39;&#39;&#39;
        return json.dumps(self.to_dict())

    def save(self):
        &#39;&#39;&#39;Save the instance to a file, which is defined by `Motion.folder` and `Motion.name`  

        Outputs
        -------
        A file named &#39;{self.folder}/{self.name}.motion&#39; will be created.
        &#39;&#39;&#39;
        with open(f&#39;{self.folder}/{self.name}.motion&#39;, &#39;w&#39;) as f:
            f.write(self.to_json())

    @staticmethod
    def read_dict(it):
        &#39;&#39;&#39;Create a instance by the dict generated by `Motion.to_dict`.  

        Parameters
        ----------
        `it` : dict

        Returns
        -------
        `mo` : `Motion`
        &#39;&#39;&#39;
        mo = Motion(folder=it[&#39;folder&#39;], name=it[&#39;name&#39;])
        mo.dt = it[&#39;dt&#39;]
        mo.damping = it[&#39;damping&#39;]
        mo.information = it[&#39;information&#39;]
        mo.accel = np.array(it[&#39;accel&#39;])
        mo.spectrum = Spectrum.read_dict(it[&#39;spectrum&#39;])
        return mo

    @staticmethod
    def read_json(string):
        &#39;&#39;&#39;Create a new instance by the string generated by `Motion.to_json`.  

        Parameters
        ----------
        `string` : str

        Returns
        -------
        `mo` : `Motion`
        &#39;&#39;&#39;
        it = json.loads(string)
        return Motion.read_dict(it)

    @staticmethod
    def load(filename):
        &#39;&#39;&#39;Load the file created from `Motion.save` method.  

        Parameters
        ----------
        `filename` : str

        Returns
        -------
        `mo` : `Motion`
        &#39;&#39;&#39;
        if not filename.endswith(&#39;.motion&#39;):
            filename += &#39;.motion&#39;
        with open(filename, &#39;r&#39;) as f:
            return Motion.read_json(f.read())

    def copy(self):
        &#39;&#39;&#39;Copy the instance.

        Returns
        -------
        `mo` : `Motion`
        &#39;&#39;&#39;
        return Motion.read_dict(self.to_dict())</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyearthquake.Motion.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Load the file created from <a title="pyearthquake.Motion.save" href="#pyearthquake.Motion.save"><code>Motion.save()</code></a> method.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : str</p>
<h2 id="returns">Returns</h2>
<p><code>mo</code> : <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(filename):
    &#39;&#39;&#39;Load the file created from `Motion.save` method.  

    Parameters
    ----------
    `filename` : str

    Returns
    -------
    `mo` : `Motion`
    &#39;&#39;&#39;
    if not filename.endswith(&#39;.motion&#39;):
        filename += &#39;.motion&#39;
    with open(filename, &#39;r&#39;) as f:
        return Motion.read_json(f.read())</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.read_dict"><code class="name flex">
<span>def <span class="ident">read_dict</span></span>(<span>it)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a instance by the dict generated by <a title="pyearthquake.Motion.to_dict" href="#pyearthquake.Motion.to_dict"><code>Motion.to_dict()</code></a>.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>it</code> : dict</p>
<h2 id="returns">Returns</h2>
<p><code>mo</code> : <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_dict(it):
    &#39;&#39;&#39;Create a instance by the dict generated by `Motion.to_dict`.  

    Parameters
    ----------
    `it` : dict

    Returns
    -------
    `mo` : `Motion`
    &#39;&#39;&#39;
    mo = Motion(folder=it[&#39;folder&#39;], name=it[&#39;name&#39;])
    mo.dt = it[&#39;dt&#39;]
    mo.damping = it[&#39;damping&#39;]
    mo.information = it[&#39;information&#39;]
    mo.accel = np.array(it[&#39;accel&#39;])
    mo.spectrum = Spectrum.read_dict(it[&#39;spectrum&#39;])
    return mo</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>string)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a new instance by the string generated by <a title="pyearthquake.Motion.to_json" href="#pyearthquake.Motion.to_json"><code>Motion.to_json()</code></a>.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>string</code> : str</p>
<h2 id="returns">Returns</h2>
<p><code>mo</code> : <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_json(string):
    &#39;&#39;&#39;Create a new instance by the string generated by `Motion.to_json`.  

    Parameters
    ----------
    `string` : str

    Returns
    -------
    `mo` : `Motion`
    &#39;&#39;&#39;
    it = json.loads(string)
    return Motion.read_dict(it)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyearthquake.Motion.accel"><code class="name">var <span class="ident">accel</span></code></dt>
<dd>
<section class="desc"><p>numpy.ndarray. Acceleration time history with evenly distributed sampling points.</p></section>
</dd>
<dt id="pyearthquake.Motion.damping"><code class="name">var <span class="ident">damping</span></code></dt>
<dd>
<section class="desc"><p>float. The damping ratio of the spectrum. Note: init with 0.05.</p></section>
</dd>
<dt id="pyearthquake.Motion.dt"><code class="name">var <span class="ident">dt</span></code></dt>
<dd>
<section class="desc"><p>float. Acceleration time sampling delta t.</p></section>
</dd>
<dt id="pyearthquake.Motion.folder"><code class="name">var <span class="ident">folder</span></code></dt>
<dd>
<section class="desc"><p>str. See <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a>.</p></section>
</dd>
<dt id="pyearthquake.Motion.information"><code class="name">var <span class="ident">information</span></code></dt>
<dd>
<section class="desc"><p>str. Store massive infomation about the motion.</p></section>
</dd>
<dt id="pyearthquake.Motion.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>str. See <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a>.</p></section>
</dd>
<dt id="pyearthquake.Motion.spectrum"><code class="name">var <span class="ident">spectrum</span></code></dt>
<dd>
<section class="desc"><p><a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a>. The spectrum of the motion.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyearthquake.Motion.change_dt"><code class="name flex">
<span>def <span class="ident">change_dt</span></span>(<span>self, dt, new_name, new_folder=None, log=True, log_folder=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Change dt for the accel. Linearly interpolate the acceleration, and re-sample.
Note: no low-pass filters are used. May cause new peaks in the Fourier spectrum.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>dt</code> : float<br>
New sampling delta t. </p>
<p><code>new_name</code> : str
</p>
<p><code>new_folder</code> : str, None
</p>
<p><code>log</code> : boolean<br>
If log, create a log picture comparing the before and after accels and spectrum.</p>
<p><code>log_folder</code> : str, None<br>
Path for the folder to save the trim logs.
If None, save in the previous folder.</p>
<h2 id="returns">Returns</h2>
<p><code>motion</code> : <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a>
</p>
<h2 id="outputs">Outputs</h2>
<p>If log, create a picture named '{log_folder}/{new_name}_dtlog.png'.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_dt(self, dt, new_name, new_folder=None, log=True, log_folder=None):
    &#39;&#39;&#39;Change dt for the accel. Linearly interpolate the acceleration, and re-sample.
    Note: no low-pass filters are used. May cause new peaks in the Fourier spectrum.  

    Parameters
    ----------
    `dt` : float  
        New sampling delta t. 

    `new_name` : str  

    `new_folder` : str, None  

    `log` : boolean  
        If log, create a log picture comparing the before and after accels and spectrum.

    `log_folder` : str, None  
        Path for the folder to save the trim logs.
        If None, save in the previous folder.

    Returns
    -------
    `motion` : `Motion`  

    Outputs
    -------
    If log, create a picture named &#39;{log_folder}/{new_name}_dtlog.png&#39;.
    &#39;&#39;&#39;
    if dt == self.dt:
        print(f&#39;Motion {self.name} do not need to change dt&#39;)
        return self.copy()
    else:
        mo = self.copy()
        mo.name = new_name
        mo.folder = new_folder if new_folder is not None else self.folder
        f = interp1d(self.get_times(), self.accel)
        npts = np.floor(self.dt * len(self.accel) / dt)
        mo.accel = f(np.arange(npts)*dt)
        mo.dt = dt
        mo.generate_spectrum()
        print(f&#39;Motion dt changed from {self.name}:{self.dt:.4f}s to {mo.name}:{dt:.4f}s.&#39;)
    if log:
        log_folder = self.folder if log_folder is None else log_folder
        os.makedirs(log_folder, exist_ok=True)
        _, ax = plt.subplots(3, 1, figsize=(7, 5))
        ax[0].plot(self.get_times(), self.accel, label=&#39;before&#39;)
        ax[1].plot(mo.get_times(), mo.accel, label=&#39;after&#39;)
        ax[2].plot(self.spectrum.periods, self.spectrum.spectrum, label=&#39;before&#39;)
        ax[2].plot(mo.spectrum.periods, mo.spectrum.spectrum, label=&#39;after&#39;)
        for i in range(3):
            ax[i].legend()
        plt.suptitle(f&#39;Change dt: {self.name}:{self.dt:.4f}s to {mo.name}:{dt:.4f}s.&#39;)
        plt.savefig(f&#39;{log_folder}/{mo.name}_dtlog.png&#39;, dpi=200)
    return mo</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.convert_peer"><code class="name flex">
<span>def <span class="ident">convert_peer</span></span>(<span>self, peer_filename)</span>
</code></dt>
<dd>
<section class="desc"><p>A recipe to convert the peer acceleration file to the .motion file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>peer_filename</code> : str
</p>
<p><code>folder</code> : str<br>
the folder to save .motion file.</p>
<h2 id="outputs">Outputs</h2>
<p>A .motion file will be created in <code>folder</code> with the PEER filename.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_peer(self, peer_filename):
    &#39;&#39;&#39;A recipe to convert the peer acceleration file to the .motion file.  

    Parameters
    ----------
    `peer_filename` : str  

    `folder` : str  
        the folder to save .motion file.

    Outputs
    -------
    A .motion file will be created in `folder` with the PEER filename.
    &#39;&#39;&#39;
    print(f&#39;Converting PEER file {peer_filename} to folder {self.folder} with name {self.name}&#39;)
    self.load_peer(peer_filename)
    self.generate_spectrum()
    self.save()</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy the instance.</p>
<h2 id="returns">Returns</h2>
<p><code>mo</code> : <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#39;&#39;&#39;Copy the instance.

    Returns
    -------
    `mo` : `Motion`
    &#39;&#39;&#39;
    return Motion.read_dict(self.to_dict())</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.generate_spectrum"><code class="name flex">
<span>def <span class="ident">generate_spectrum</span></span>(<span>self, periods=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Use scipy LTS signal processing module to generate the spectrum.<br>
Note that the accel spectrum is pseudo-spectrum derived from disp spectrum.<br>
So it's only accurate when damping is small.<br>
If <a title="pyearthquake.Motion.dt" href="#pyearthquake.Motion.dt"><code>Motion.dt</code></a> is still None, which usually occurs if the PEER file is not well formated,
a blank spectrum will be returned.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>periods</code> : List-like, None
<br>
The period sampling points. <br>
If is None, <a title="pyearthquake.Spectrum.periods_standard" href="#pyearthquake.Spectrum.periods_standard"><code>Spectrum.periods_standard()</code></a> will be called.</p>
<h2 id="returns">Returns</h2>
<p><code>spectrum</code> : <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a><br>
The generated spectrum.</p>
<h2 id="outputs">Outputs</h2>
<p><a title="pyearthquake.Motion.spectrum" href="#pyearthquake.Motion.spectrum"><code>Motion.spectrum</code></a> will be changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_spectrum(self, periods=None):
    &#39;&#39;&#39;Use scipy LTS signal processing module to generate the spectrum.  
    Note that the accel spectrum is pseudo-spectrum derived from disp spectrum.  
    So it&#39;s only accurate when damping is small.  
    If `Motion.dt` is still None, which usually occurs if the PEER file is not well formated, 
        a blank spectrum will be returned.  

    Parameters
    ----------
    `periods` : List-like, None    
        The period sampling points.   
        If is None, `Spectrum.periods_standard` will be called.

    Returns
    -------
    `spectrum` : `Spectrum`  
        The generated spectrum.

    Outputs
    -------
    `Motion.spectrum` will be changed.
    &#39;&#39;&#39;
    if periods is None:
        periods = Spectrum.periods_standard()
    if self.dt is not None:
        print(&#34;Generating spectrum ...&#34;)
        omegas = 2 * np.pi / periods[1:]
        num = np.array([-1])
        spectrum = np.zeros(len(periods))
        spectrum[0] = self.get_PGA()
        for i, omega in enumerate(omegas):
            den = np.array([1, 2*self.damping*omega, omega**2])
            _, y, _ = lsim((num, den), self.accel, self.get_times())
            spectrum[i+1] = np.max(abs(y)) * omega ** 2
        self.spectrum = Spectrum(periods, spectrum)
    else:
        print(&#34;Dt is not known. Assigning empty spectrum.&#34;)
        self.spectrum = Spectrum(periods=[], spectrum=[])
    return self.spectrum</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.get_PGA"><code class="name flex">
<span>def <span class="ident">get_PGA</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<p><code>value</code> : float<br>
The peak ground acceleration.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_PGA(self):
    &#39;&#39;&#39;
    Returns
    -------
    `value` : float  
        The peak ground acceleration.  
    &#39;&#39;&#39;
    return np.max(abs(self.accel))</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.get_duration"><code class="name flex">
<span>def <span class="ident">get_duration</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<p><code>value</code> : float<br>
The duration of the motion.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_duration(self):
    &#39;&#39;&#39;
    Returns
    -------
    `value` : float  
        The duration of the motion.  
    &#39;&#39;&#39;
    return (len(self.accel) - 1) * self.dt</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.get_times"><code class="name flex">
<span>def <span class="ident">get_times</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<p><code>value</code> : numpy.ndarray<br>
The time series of the motion</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_times(self):
    &#39;&#39;&#39;
    Returns
    -------
    `value` : numpy.ndarray  
        The time series of the motion  
    &#39;&#39;&#39;
    return np.arange(len(self.accel)) * self.dt</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.load_peer"><code class="name flex">
<span>def <span class="ident">load_peer</span></span>(<span>self, peer_filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Load acceleration time-history files downloaded from PEER.<br>
The strings in the file will be parsed and also stored in self.information.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>peer_filename</code> : str</p>
<h2 id="outputs">Outputs</h2>
<p><a title="pyearthquake.Motion.dt" href="#pyearthquake.Motion.dt"><code>Motion.dt</code></a>, <a title="pyearthquake.Motion.accel" href="#pyearthquake.Motion.accel"><code>Motion.accel</code></a>, <a title="pyearthquake.Motion.information" href="#pyearthquake.Motion.information"><code>Motion.information</code></a>, <a title="pyearthquake.Motion.spectrum" href="#pyearthquake.Motion.spectrum"><code>Motion.spectrum</code></a> will all be changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_peer(self, peer_filename):
    &#39;&#39;&#39;Load acceleration time-history files downloaded from PEER.  
    The strings in the file will be parsed and also stored in self.information.  

    Parameters
    ----------
    `peer_filename` : str

    Outputs
    -------
    `Motion.dt`, `Motion.accel`, `Motion.information`, `Motion.spectrum` will all be changed.  
    &#39;&#39;&#39;
    self.information += f&#39;peer_filename: {peer_filename}&#39;
    try:
        f = open(peer_filename, &#39;r&#39;)
        for _ in range(3):
            self.information += f.readline()
        s = f.readline()
        self.information += s
        re_dt = re.compile(r&#34;.*[ 0](\.[0-9]*) ?SEC&#34;)
        mt = re_dt.match(s)
        try:
            self.dt = float(mt.group(1).replace(&#39;.&#39;, &#39;0.&#39;))
            print(f&#39;Extracted dt = {self.dt:.4f}&#39;)
        except:
            print(f&#39;ERROR: cannot find dt from {s}&#39;)
            self.dt = 0.000001
        series = []
        datastring = f.readlines()
        for dtline in datastring:
            for dt in dtline.split(&#34;  &#34;):
                if dt:
                    try:
                        series.append(float(dt.replace(&#34;.&#34;, &#34;0.&#34;)))
                    except ValueError:
                        break
        self.accel = np.array(series)
        print(f&#39;Extracted npts = {len(self.accel)}&#39;)
    except IOError:
        print(f&#39;No file named {self.name} is found.&#39;)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, folder=None, save=True, engine='pyplot')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the time history and the spectrum.</p>
<h2 id="parameters">Parameters</h2>
<p>See <a title="pyearthquake.Motion.plot_timehistory" href="#pyearthquake.Motion.plot_timehistory"><code>Motion.plot_timehistory()</code></a></p>
<h2 id="outputs">Outputs</h2>
<p>Create a figure named '{folder}/{name}'</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, folder=None, save=True, engine=&#39;pyplot&#39;):
    &#39;&#39;&#39;Plot the time history and the spectrum.

    Parameters
    ----------
    See `Motion.plot_timehistory`

    Outputs
    -------
    Create a figure named &#39;{folder}/{name}&#39;
    &#39;&#39;&#39;
    folder = self.folder if folder is None else folder
    if engine == &#39;pyplot&#39;:
        _, ax = plt.subplots(2, 1, figsize=(7, 8))
        ax[0].plot(self.get_times(), self.accel)
        ax[0].set_xlabel(&#39;Time(s)&#39;)
        ax[0].set_ylabel(&#39;Acceleration(g)&#39;)
        ax[0].set_title(f&#39;PGA={self.get_PGA():.4f}&#39;)
        ax[1].plot(self.spectrum.periods, self.spectrum.spectrum)
        ax[1].set_xlabel(&#39;Period(s)&#39;)
        ax[1].set_ylabel(&#39;Spectrum Acceleration(g)&#39;)
        ax[1].set_title(f&#39;damping={self.damping:.4f}&#39;)
        plt.subplots_adjust(hspace=0.3)
        if save:
            plt.savefig(f&#39;{folder}/{self.name}.png&#39;, dpi=200)
        else:
            plt.show()
    elif engine == &#39;plotly&#39;:
        fig = make_subplots(rows=1, cols=2)
        fig.add_trace(go.Scatter(
            x=self.get_times(),
            y=self.accel,
            mode=&#39;lines&#39;,
            name=&#39;accel&#39;
        ), row=1, col=2)
        fig.add_trace(go.Scatter(
            x=self.spectrum.periods,
            y=self.spectrum.spectrum,
            mode=&#39;lines&#39;,
            name=&#39;spectrum&#39;
        ), row=1, col=1)
        if save:
            fig.write_html(f&#39;{folder}/{self.name}.html&#39;)
        else:
            fig.show()
    else:
        print(&#39;Engine should be in &#34;pyplot&#34; or &#34;plotly&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.plot_timehistory"><code class="name flex">
<span>def <span class="ident">plot_timehistory</span></span>(<span>self, folder=None, save=True, engine='pyplot')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the time history of the acceleration.</p>
<h2 id="parameters">Parameters</h2>
<p><code>folder</code> : str, None<br>
Store folder. If None, use <a title="pyearthquake.Motion.folder" href="#pyearthquake.Motion.folder"><code>Motion.folder</code></a> </p>
<p><code>save</code> : boolean
Save the figure or not. </p>
<p><code>engine</code> : 'pyplot' or 'plotly'
</p>
<h2 id="outputs">Outputs</h2>
<p>if save is True, create a figure '{folder}/{self.name}_th'.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_timehistory(self, folder=None, save=True, engine=&#39;pyplot&#39;):
    &#39;&#39;&#39;Plot the time history of the acceleration.

    Parameters
    ----------
    `folder` : str, None  
        Store folder. If None, use `Motion.folder` 

    `save` : boolean
        Save the figure or not. 

    `engine` : &#39;pyplot&#39; or &#39;plotly&#39;  

    Outputs
    -------
    if save is True, create a figure &#39;{folder}/{self.name}_th&#39;.
    &#39;&#39;&#39;
    folder = self.folder if folder is None else folder
    if engine == &#39;pyplot&#39;:
        plt.figure()
        t = self.get_times()
        plt.plot(t, self.accel)
        if save:
            plt.savefig(f&#39;{folder}/{self.name}_th.png&#39;, dpi=200)
        else:
            plt.show()
    elif engine == &#39;plotly&#39;:
        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=self.get_times(),
            y=self.accel,
            mode=&#39;lines&#39;,
            name=self.name
        ))
        if save:
            fig.write_html(f&#39;{folder}/{self.name}_th.html&#39;)
        else:
            fig.show()
    else:
        print(&#39;ERROR: engine should be in &#34;pyplot&#34; or &#34;plotly&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.read_accel"><code class="name flex">
<span>def <span class="ident">read_accel</span></span>(<span>self, filename, dt=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Load an single-column acceleration file to the current instance.</p>
<h2 id="parameters">Parameters</h2>
<p><code>dt</code> : float, boolean
if dt is float, <a title="pyearthquake.Motion.dt" href="#pyearthquake.Motion.dt"><code>Motion.dt</code></a> will be set to dt.
Else if dt is True, <a title="pyearthquake.Motion.dt" href="#pyearthquake.Motion.dt"><code>Motion.dt</code></a> will be found in the file.</p>
<h2 id="outputs">Outputs</h2>
<p>Change <a title="pyearthquake.Motion.dt" href="#pyearthquake.Motion.dt"><code>Motion.dt</code></a> and <a title="pyearthquake.Motion.accel" href="#pyearthquake.Motion.accel"><code>Motion.accel</code></a> in the CURRENT instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_accel(self, filename, dt=True):
    &#39;&#39;&#39;Load an single-column acceleration file to the current instance.

    Parameters
    ----------
    `dt` : float, boolean
        if dt is float, `Motion.dt` will be set to dt.
        Else if dt is True, `Motion.dt` will be found in the file.

    Outputs
    -------
    Change `Motion.dt` and `Motion.accel` in the CURRENT instance.
    &#39;&#39;&#39;
    if not isinstance(dt, float):
        data = np.loadtxt(filename)
        self.accel = data[:, 1]
        self.dt = data[1, 0]
    else:
        self.accel = np.loadtxt(filename)
        self.dt = dt</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.read_info"><code class="name flex">
<span>def <span class="ident">read_info</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Read info from text file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : str</p>
<h2 id="outputs">Outputs</h2>
<p>The <a title="pyearthquake.Motion.information" href="#pyearthquake.Motion.information"><code>Motion.information</code></a> of the CURRENT instance will be changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_info(self, filename):
    &#39;&#39;&#39;Read info from text file.  

    Parameters
    ----------
    `filename` : str

    Outputs
    -------
    The `Motion.information` of the CURRENT instance will be changed.
    &#39;&#39;&#39;
    with open(filename, &#39;r&#39;) as f:
        self.dt = float(f.readline().replace(&#34;dt=&#34;, &#34;&#34;))
        _ = int(f.readline().replace(&#34;npts=&#34;, &#34;&#34;))
        self.damping = float(f.readline().replace(&#34;damping=&#34;, &#34;&#34;))
        self.information = f.read()</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.read_spectrum"><code class="name flex">
<span>def <span class="ident">read_spectrum</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Read the spectrum from csv file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : str</p>
<h2 id="outputs">Outputs</h2>
<p>The <a title="pyearthquake.Motion.spectrum" href="#pyearthquake.Motion.spectrum"><code>Motion.spectrum</code></a> of the CURRENT instance will be changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_spectrum(self, filename):
    &#39;&#39;&#39;Read the spectrum from csv file.  

    Parameters
    ----------
    `filename` : str

    Outputs
    -------
    The `Motion.spectrum` of the CURRENT instance will be changed.
    &#39;&#39;&#39;
    spectrum = Spectrum.read_csv(filename)
    self.spectrum = spectrum</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Save the instance to a file, which is defined by <a title="pyearthquake.Motion.folder" href="#pyearthquake.Motion.folder"><code>Motion.folder</code></a> and <a title="pyearthquake.Motion.name" href="#pyearthquake.Motion.name"><code>Motion.name</code></a>
</p>
<h2 id="outputs">Outputs</h2>
<p>A file named '{self.folder}/{self.name}.motion' will be created.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
    &#39;&#39;&#39;Save the instance to a file, which is defined by `Motion.folder` and `Motion.name`  

    Outputs
    -------
    A file named &#39;{self.folder}/{self.name}.motion&#39; will be created.
    &#39;&#39;&#39;
    with open(f&#39;{self.folder}/{self.name}.motion&#39;, &#39;w&#39;) as f:
        f.write(self.to_json())</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, new_name, new_folder=None, factor_x=1, factor_y=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Scale the ground motion.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>new_name</code> : str</p>
<p><code>new_folder</code> : str, None</p>
<p><code>factor_x</code> : float<br>
The scaling factor on the time/period axis.
</p>
<p><code>factor_y</code> : float
The scaling factor on the accel axis.</p>
<h2 id="returns">Returns</h2>
<p><code>motion</code> : Motion</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, new_name, new_folder=None, factor_x=1, factor_y=1):
    &#39;&#39;&#39;Scale the ground motion.  

    Parameters
    ----------
    `new_name` : str

    `new_folder` : str, None

    `factor_x` : float  
        The scaling factor on the time/period axis.  

    `factor_y` : float
        The scaling factor on the accel axis.

    Returns
    -------
    `motion` : Motion
    &#39;&#39;&#39;
    mo = self.copy()
    mo.name = new_name
    mo.folder = new_folder if new_folder is not None else self.folder
    if factor_x != 1:
        mo.dt = self.dt * factor_x
    if factor_y != 1:
        mo.accel = self.accel * factor_y
    mo.spectrum = self.spectrum.scale(factor_x, factor_y)
    return mo</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert the instance properties to dict.
</p>
<h2 id="returns">Returns</h2>
<p><code>it</code> : dict</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    &#39;&#39;&#39;Convert the instance properties to dict.  

    Returns
    -------
    `it` : dict
    &#39;&#39;&#39;
    return dict(
        dt=self.dt,
        npts=len(self.accel),
        damping=self.damping,
        information=self.information,
        accel=self.accel.tolist(),
        spectrum=self.spectrum.to_dict(),
        folder=self.folder,
        name=self.name,
    )</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert the instance properties to string using json format.
</p>
<h2 id="returns">Returns</h2>
<p><code>string</code> : str</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self):
    &#39;&#39;&#39;Convert the instance properties to string using json format.  

    Returns
    -------
    `string` : str
    &#39;&#39;&#39;
    return json.dumps(self.to_dict())</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.trim"><code class="name flex">
<span>def <span class="ident">trim</span></span>(<span>self, new_name, new_folder=None, left=0.001, right=0.001, prepend_zero=True, log=True, log_folder=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Trim the motion with two coefficients of PGA.<br>
This method is used when a long near-zero time-history is stored in the data file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>new_name</code> : str
</p>
<p><code>new_folder</code> : str, None
</p>
<p><code>left</code>, <code>right</code> : float
The coefficient of PGA to trim the time history.
Search from left or right, when the target point is found,
search for the nearest near-zero point. Then trim off the small values.
</p>
<p><code>prepend_zero</code> : boolean<br>
If True, prepend a zero value to the trimmed acceleration.</p>
<p><code>log</code> : boolean<br>
If the log picture will be generated.</p>
<p><code>log_folder</code> : str, None
Path for the folder to save the trim logs.
If None, save in the previous folder.</p>
<h2 id="returns">Returns</h2>
<p><code>motion</code> : <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a><br>
The trimmed motion.</p>
<h2 id="outputs">Outputs</h2>
<p>If log, plot a figure in log_folder named '{new_name}_trimlog.png'</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trim(self, new_name, new_folder=None, left=1.0e-3, right=1.0e-3, prepend_zero=True, log=True, log_folder=None):
    &#39;&#39;&#39;Trim the motion with two coefficients of PGA.  
    This method is used when a long near-zero time-history is stored in the data file.  

    Parameters
    ----------
    `new_name` : str  

    `new_folder` : str, None  

    `left`, `right` : float 
        The coefficient of PGA to trim the time history.
        Search from left or right, when the target point is found,
        search for the nearest near-zero point. Then trim off the small values.  


    `prepend_zero` : boolean  
        If True, prepend a zero value to the trimmed acceleration.

    `log` : boolean  
        If the log picture will be generated.

    `log_folder` : str, None
        Path for the folder to save the trim logs.
        If None, save in the previous folder.

    Returns
    -------
    `motion` : `Motion`  
        The trimmed motion.

    Outputs
    -------
    If log, plot a figure in log_folder named &#39;{new_name}_trimlog.png&#39;
    &#39;&#39;&#39;
    mo = self.copy()
    mo.name = new_name
    mo.folder = new_folder if new_folder is not None else self.folder
    pga = self.get_PGA()
    # search left
    i = 0
    while abs(self.accel[i]) &lt; pga * left:
        i += 1
    while i &gt; 0 and self.accel[i] * self.accel[i-1] &gt; 0:
        i -= 1
    i_left = i
    # search right
    i = -1
    while abs(self.accel[i]) &lt; pga * right:
        i -= 1
    while i &lt; -1 and self.accel[i] * self.accel[i+1] &gt; 0:
        i += 1
    i_right = len(self.accel) + i
    if prepend_zero:
        mo.accel = np.hstack([0, self.accel[i_left:i_right]])
    else:
        mo.accel = self.accel[i_left:i_right]
    mo.generate_spectrum()
    print(
        f&#39;Motion is trimmed from {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
    if log:
        log_folder = self.folder if log_folder is None else log_folder
        os.makedirs(log_folder, exist_ok=True)
        _, ax = plt.subplots(3, 1, figsize=(7, 5))
        ax[0].plot(self.get_times(), self.accel, label=&#39;before&#39;)
        ax[1].plot(mo.get_times(), mo.accel, label=&#39;after&#39;)
        ax[2].plot(self.spectrum.periods, self.spectrum.spectrum, label=&#39;before&#39;)
        ax[2].plot(mo.spectrum.periods, mo.spectrum.spectrum, label=&#39;after&#39;)
        for i in range(3):
            ax[i].legend()
        plt.suptitle(f&#39;Trim log: {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
        plt.savefig(f&#39;{log_folder}/{mo.name}_trimlog.png&#39;, dpi=200)
    return mo</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, time, new_name, new_folder=None, log=True, log_folder=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Truncate the acceleration.
Sometimes, a ground motion file may have two peaks or more.
So if only one peak is needed, this method can be used to skip the other peaks.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>time</code> : float
The accels after the time will be cut off.
</p>
<p><code>new_name</code> : str</p>
<p><code>new_folder</code> : str, None
</p>
<p><code>log</code> : boolean
</p>
<p><code>log_folder</code> : str, None
</p>
<h2 id="returns">Returns</h2>
<p><code>motion</code> : <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a></p>
<h2 id="outputs">Outputs</h2>
<p>If log is True, a figure named '{log_folder}/{new_name}_trunclog.png' will be created.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def truncate(self, time, new_name, new_folder=None, log=True, log_folder=None):
    &#39;&#39;&#39;Truncate the acceleration. 
    Sometimes, a ground motion file may have two peaks or more. 
    So if only one peak is needed, this method can be used to skip the other peaks.  

    Parameters
    ----------
    `time` : float
        The accels after the time will be cut off.  

    `new_name` : str

    `new_folder` : str, None  

    `log` : boolean  

    `log_folder` : str, None  

    Returns
    -------
    `motion` : `Motion`

    Outputs
    -------
    If log is True, a figure named &#39;{log_folder}/{new_name}_trunclog.png&#39; will be created.
    &#39;&#39;&#39;
    i = round(time / self.dt)
    mo = self.copy()
    mo.name = new_name
    mo.folder = new_folder if new_folder is not None else self.folder
    if i &gt;= len(self.accel):
        print(f&#34;WARNING: time is longer than duration. {self.name} is not truncated.&#34;)
        return mo
    mo.accel = self.accel[:i]
    mo.generate_spectrum()
    print(f&#39;Motion truncated: {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
    if log:
        log_folder = self.folder if log_folder is None else log_folder
        os.makedirs(log_folder, exist_ok=True)
        _, ax = plt.subplots(3, 1, figsize=(7, 5))
        ax[0].plot(self.get_times(), self.accel, label=&#39;before&#39;)
        ax[1].plot(mo.get_times(), mo.accel, label=&#39;after&#39;)
        ax[2].plot(self.spectrum.periods, self.spectrum.spectrum, label=&#39;before&#39;)
        ax[2].plot(mo.spectrum.periods, mo.spectrum.spectrum, label=&#39;after&#39;)
        for i in range(3):
            ax[i].legend()
        plt.suptitle(f&#39;Truncate: {self.name}:{len(self.accel)*self.dt:.3f}s to {mo.name}:{len(mo.accel)*mo.dt:.3f}s.&#39;)
        plt.savefig(f&#39;{log_folder}/{mo.name}_trunclog.png&#39;, dpi=200)
    return mo</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.write_accel"><code class="name flex">
<span>def <span class="ident">write_accel</span></span>(<span>self, filename, time=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Write the acceleration timehistory to a single file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : str<br>
The file path to store the accelration.
</p>
<p><code>time</code> : boolean<br>
If True, a time column is created.
To know dt in the file content, time should be True.
Otherwise, dt should be stored in the filename.</p>
<h2 id="outputs">Outputs</h2>
<p>An text file with acceleration information will be written.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_accel(self, filename, time=True):
    &#39;&#39;&#39;Write the acceleration timehistory to a single file.  

    Parameters
    ----------
    `filename` : str  
        The file path to store the accelration.  

    `time` : boolean  
        If True, a time column is created.
        To know dt in the file content, time should be True.
        Otherwise, dt should be stored in the filename.

    Outputs
    -------
    An text file with acceleration information will be written.
    &#39;&#39;&#39;
    if time:
        data = np.vstack([self.get_times(), self.accel])
        np.savetxt(filename, data.T, fmt=&#34;%.4f,%.7e&#34;, header=&#34;Time,Accel&#34;)
    else:
        np.savetxt(filename, self.accel, fmt=&#34;%.7e&#34;)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.write_info"><code class="name flex">
<span>def <span class="ident">write_info</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Write the information to a single file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : str</p>
<h2 id="outputs">Outputs</h2>
<p>A text file with information will be created.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_info(self, filename):
    &#39;&#39;&#39;Write the information to a single file.  

    Parameters
    ----------
    `filename` : str

    Outputs
    -------
    A text file with information will be created.
    &#39;&#39;&#39;
    with open(filename, &#39;w&#39;) as f:
        f.write(f&#39;dt={self.dt:.3}\n&#39;)
        f.write(f&#39;npts={len(self.accel)}\n&#39;)
        f.write(f&#39;damping={self.damping:.3}\n&#39;)
        f.write(self.information)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Motion.write_spectrum"><code class="name flex">
<span>def <span class="ident">write_spectrum</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Write the spectrum to a single file. Use the form of csv.</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : str</p>
<h2 id="outputs">Outputs</h2>
<p>A csv file will be created.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_spectrum(self, filename):
    &#39;&#39;&#39;Write the spectrum to a single file. Use the form of csv.

    Parameters
    ----------
    `filename` : str

    Outputs
    -------
    A csv file will be created.
    &#39;&#39;&#39;
    self.spectrum.write_csv(filename)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyearthquake.Spectrum"><code class="flex name class">
<span>class <span class="ident">Spectrum</span></span>
<span>(</span><span>periods, spectrum)</span>
</code></dt>
<dd>
<section class="desc"><p>A class storing a spectrum.<br>
It can be init-ed simply with (periods, spectrum) sampling points.<br>
It can also be init-ed by static functions to generate Code-confined spectrums.</p>
<h2 id="parameters">Parameters</h2>
<p><code>periods</code> : List, numpy.ndarray<br>
List of sampling periods.<br>
It can be generated by the static function <a title="pyearthquake.Spectrum.periods_standard" href="#pyearthquake.Spectrum.periods_standard"><code>Spectrum.periods_standard()</code></a> .
Otherwise, users can specify desired period sampling points.
</p>
<p><code>spectrum</code> : List, numpy.ndarray<br>
List of the spectrum points corresponding to sampling periods.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spectrum():
    &#39;&#39;&#39;A class storing a spectrum.  
    It can be init-ed simply with (periods, spectrum) sampling points.  
    It can also be init-ed by static functions to generate Code-confined spectrums.

    Parameters  
    ----------  
    `periods` : List, numpy.ndarray  
        List of sampling periods.  
        It can be generated by the static function `Spectrum.periods_standard` .
        Otherwise, users can specify desired period sampling points.  

    `spectrum` : List, numpy.ndarray  
        List of the spectrum points corresponding to sampling periods.  
    &#39;&#39;&#39;

    def __init__(self, periods, spectrum):
        self.periods = np.array(periods)
        &#39;&#39;&#39;numpy.ndarray, sampling periods&#39;&#39;&#39;
        self.spectrum = np.array(spectrum)
        &#39;&#39;&#39;numpy.ndarray, spectrum corresponding to sampling periods.&#39;&#39;&#39;

    def match(self, target, start, end, step=0.1):
        &#39;&#39;&#39;Match the current spectrum with a target spectrum. Use Least Square method.  

        Parameters  
        ----------  
        `target` : `Spectrum`  
            the spectrum to be matched.  

        `start`, `end` : float  
            the matching period boundaries.  

        `step` : float
            evenly sample the periods with the step.

        Returns
        -------
        `coefficient` : float  
            the coefficient to match the current spectrum to the target.

        `srss` : float   
            the srss after match.
        &#39;&#39;&#39;
        periods = np.arange(start, end+step, step)
        this_spectrum = np.array([self.get(p) for p in periods])
        that_spectrum = np.array([target.get(p) for p in periods])
        coefficient = sum(this_spectrum * that_spectrum) / sum(this_spectrum ** 2)
        srss = (np.sum((this_spectrum * coefficient - that_spectrum) ** 2)) ** 0.5
        return coefficient, srss

    def get(self, period):
        &#39;&#39;&#39;Get the spectrum value. Either a list or a number is accepted.  
        If the period exceeds the largest sampling period, the last spectrum value is returned.  
        The spectrum value not on sampling points are linearly interpolated.  

        Parameters
        ----------
        `period` : number, list, numpy.ndarray  
            The interested period.

        Returns
        -------
        `spectrum` : number, numpy.ndarray  
            if period is list-like, return a ndarray.
            if period is a number, return a number.
        &#39;&#39;&#39;
        if not hasattr(period, &#39;__iter__&#39;):
            i = self.periods.searchsorted(period)
            if self.periods[i] == period:
                return self.spectrum[i]
            elif i &gt;= len(self.periods):
                print(&#34;Warning: given period exceeds the sampling range.&#34;)
                return self.spectrum[-1]
            else:
                return self.spectrum[i] - (self.spectrum[i]-self.spectrum[i-1]) / (self.periods[i] - self.periods[i-1]) * (self.periods[i] - period)
        else:
            return np.array([self.get(p) for p in period])

    def scale(self, factor_x=1, factor_y=1):
        &#39;&#39;&#39;Scale the spectrum.

        Parameters
        ----------
        `factor_x` : number  
            scaling factor in x direction (periods)  

        `factor_y` : number  
            scaling factor in y direction (spectrum)

        Returns
        -------
        `spectrum` : `Spectrum`
        &#39;&#39;&#39;
        return Spectrum(periods=self.periods*factor_x, spectrum=self.spectrum*factor_y)

    def plot(self, filename=None, engine=&#39;pyplot&#39;):
        &#39;&#39;&#39;Plot the spectrum.

        Parameters
        ----------
        `filename` : string, None  
            if None, show it. Else, save it to the filename  

        `engine` : &#39;pyplot&#39; or &#39;plotly&#39;  
            Plot engine.

        Outputs
        -------
        A file with name `filename`.png or `filename`.html will be generated.
        &#39;&#39;&#39;
        if engine == &#39;pyplot&#39;:
            plt.figure(figsize=(4, 3))
            plt.plot(self.periods, self.spectrum, marker=&#39;o&#39;)
            plt.xlabel(&#39;Period (s)&#39;)
            plt.ylabel(&#39;Spetrum&#39;)
            plt.xlim([0, self.periods[-1]])
            if filename is None:
                plt.show()
            else:
                plt.savefig(filename+&#39;.png&#39;, dpi=200)
        elif engine == &#39;plotly&#39;:
            fig = go.Figure()
            fig.add_scatter(dict(
                x=&#39;self.periods&#39;,
                y=&#39;self.spectrum&#39;,
                mode=&#39;lines+markers&#39;,
            ))
            if filename is None:
                fig.show()
            else:
                fig.write_html(filename+&#39;.html&#39;)
        else:
            print(&#39;ERROR: engine should be in &#34;pyplot&#34; or &#34;plotly&#34;&#39;)

    def to_dict(self):
        &#39;&#39;&#39;Convert the instance properties to a dict.  

        Returns
        -------
        `it` : dict
        &#39;&#39;&#39;
        return dict(
            periods=self.periods.tolist(),
            spectrum=self.spectrum.tolist()
        )

    def to_json(self):
        &#39;&#39;&#39;Convert the properties to json.  

        Returns
        -------
        `json` : string  
        &#39;&#39;&#39;
        return json.dumps(self.to_dict())

    def save(self, filename):
        &#39;&#39;&#39;Save the spectrum to a file. Currently use json form.  

        Parameters
        ----------
        `filename` : string  
            The file name to be saved.   
            The extension &#39;.spectrum&#39; will be automatically added.  

        Outputs
        -------
        A file with name `filename`.spectrum will be generated.
        &#39;&#39;&#39;
        with open(filename + &#39;.spectrum&#39;, &#39;w&#39;) as f:
            f.write(self.to_json())

    def write_csv(self, filename):
        &#39;&#39;&#39;Write the spectrum to a csv file.  

        Parameters
        ----------
        `filename` : string  
            The extension &#39;.csv&#39; will be automatically added.

        Outputs
        -------
        A file named `filename`.csv will be generated.
        &#39;&#39;&#39;
        np.savetxt(filename+&#39;.csv&#39;, np.vstack(
            [self.periods, self.spectrum]).T, fmt=&#34;%.3f,%.7f&#34;, header=&#39;Period,Spectrum&#39;)

    @staticmethod
    def read_csv(filename):
        &#39;&#39;&#39;Create an instance by reading the written csv file.  

        Parameters
        ----------
        `filename` : string  
            The filename to read.

        Returns
        -------
        `spectrum` : `Spectrum`  
            New instance.
        &#39;&#39;&#39;
        if not filename.endswith(&#39;.csv&#39;):
            filename += &#39;.csv&#39;
        data = np.loadtxt(filename, delimiter=&#39;,&#39;)
        return Spectrum(periods=data[:, 0], spectrum=data[:, 1])

    @staticmethod
    def read_dict(it):
        &#39;&#39;&#39;Create an instance from the dict.  

        Parameters
        ----------
        `it` : dict  
            The dict generated by `Spectrum.to_dict`

        Returns
        -------
        `spectrum` : `Spectrum`  
            New instance.
        &#39;&#39;&#39;
        return Spectrum(periods=it[&#39;periods&#39;], spectrum=it[&#39;spectrum&#39;])

    @staticmethod
    def read_json(string):
        &#39;&#39;&#39;Create an instance from json string.  

        Parameters
        ----------
        `string` : str  
            The json string 

        Returns
        -------
        `spectrum` : `Spectrum`  
            New instance.
        &#39;&#39;&#39;
        it = json.loads(string)
        return Spectrum.read_dict(it)

    @staticmethod
    def load(filename):
        &#39;&#39;&#39;Load the spectrum from file.  

        Parameters
        ----------
        `filename` : str  

        Returns
        -------
        `spectrum` : `Spectrum`  
            New instance.
        &#39;&#39;&#39;
        if not filename.endswith(&#39;.spectrum&#39;):
            filename += &#39;.spectrum&#39;
        with open(filename, &#39;r&#39;) as f:
            string = f.read()
        return Spectrum.read_json(string)

    @staticmethod
    def periods_standard(until=6):
        &#39;&#39;&#39;Get a standard sampling of the periods.  
        The sampling points are more sparse with the increase of period.  

        Parameters
        ----------  
        `until` : number  
            The end of the period sampling list. It should &gt;= 4.0.

        Returns
        -------
        `periods` : numpy.ndarray  
            The standard sampling points.
        &#39;&#39;&#39;
        assert until &gt;= 4
        return np.hstack([np.arange(0, 0.2, 0.01),
                          np.arange(0.2, 0.5, 0.02),
                          np.arange(0.5, 1.0, 0.05),
                          np.arange(1.0, 2.0, 0.1),
                          np.arange(2.0, 4.0, 0.2),
                          np.arange(4.0, until+0.5, 0.5)])

    @staticmethod
    def chinese_point(period, intensity, major, site, group, damping=0.05):
        &#39;&#39;&#39;Get spectrum point for Chinese code, given a period.  

        Parameters
        ----------  
        `period` : number  
            The given period.  

        `intensity` : number  
            Intensity represented by a number.   
            Use 7.5 or 8.5 for half-level intensity.  

        `major` : boolean
            If True, it&#39;s for major (rare) earthquake.  
            If False, for minor (frequent) earthquake.  

        `site` : int
            Site number (Roman number in the code. 0 for I0, 1 for I1.)  

        `group` : int  
            Site class (Chinese number in the code.)  

        `damping` : float  
            Spectrum damping.  

        Returns
        -------  
        `value` : float
            the specific spectrum point value corresponding to the period.  
        &#39;&#39;&#39;
        # alpha max
        if intensity == 6:
            alphamax = 0.28 if major else 0.04
        elif intensity == 7:
            alphamax = 0.50 if major else 0.08
        elif intensity == 7.5:
            alphamax = 0.72 if major else 0.12
        elif intensity == 8:
            alphamax = 0.9 if major else 0.16
        elif intensity == 8.5:
            alphamax = 1.2 if major else 0.24
        elif intensity == 9:
            alphamax = 1.40 if major else 0.32
        else:
            raise(&#34;ERROR: intensity not in [6, 7, 7.5, 8, 8.5, 9]&#34;)
        # tg
        tg_table = [[0.20, 0.25, 0.35, 0.45, 0.65],
                    [0.25, 0.3, 0.4, 0.55, 0.75],
                    [0.3, 0.35, 0.45, 0.65, 0.9]]
        assert group in [1, 2, 3] and site in [0, 1, 2, 3, 4]
        tg = tg_table[group-1][site]
        # other parameters
        gamma = 0.9 + (0.05 - damping) / (0.3 + 6*damping)
        eta1 = 0.02 + (0.05 - damping) / (4 + 32*damping)
        eta2 = 1 + (0.05 - damping) / (0.08 + 1.6*damping)
        # calculate
        if period &lt; 0.1:
            return ((10*eta2 - 4.5) * period + 0.45) * alphamax
        elif period &lt; tg:
            return eta2 * alphamax
        elif period &lt; 5*tg:
            return (tg/period)**gamma * eta2 * alphamax
        elif period &lt;= 6:
            return (eta2 * 0.2**gamma - eta1 * (period-5*tg)) * alphamax
        else:
            return (eta2 * 0.2**gamma - eta1 * (6-5*tg)) * alphamax

    @staticmethod
    def chinese(intensity=8, major=True, site=3, group=2, damping=0.05):
        &#39;&#39;&#39;Return a new spectrum instance that confines to Chinese Code.  
        Use `Spectrum.periods_standard` to get sampling periods.  

        Parameters
        ----------
        refer to `Spectrum.chinese_point`

        Returns
        -------
        `spectrum` : `Spectrum`
        &#39;&#39;&#39;
        periods = Spectrum.periods_standard(until=6)
        spectrum = [Spectrum.chinese_point(p, 
                                           intensity=intensity,
                                           major=major,
                                           site=site,
                                           group=group,
                                           damping=damping) for p in periods]
        return Spectrum(periods, spectrum)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyearthquake.Spectrum.chinese"><code class="name flex">
<span>def <span class="ident">chinese</span></span>(<span>intensity=8, major=True, site=3, group=2, damping=0.05)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a new spectrum instance that confines to Chinese Code.<br>
Use <a title="pyearthquake.Spectrum.periods_standard" href="#pyearthquake.Spectrum.periods_standard"><code>Spectrum.periods_standard()</code></a> to get sampling periods.
</p>
<h2 id="parameters">Parameters</h2>
<p>refer to <a title="pyearthquake.Spectrum.chinese_point" href="#pyearthquake.Spectrum.chinese_point"><code>Spectrum.chinese_point()</code></a></p>
<h2 id="returns">Returns</h2>
<p><code>spectrum</code> : <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def chinese(intensity=8, major=True, site=3, group=2, damping=0.05):
    &#39;&#39;&#39;Return a new spectrum instance that confines to Chinese Code.  
    Use `Spectrum.periods_standard` to get sampling periods.  

    Parameters
    ----------
    refer to `Spectrum.chinese_point`

    Returns
    -------
    `spectrum` : `Spectrum`
    &#39;&#39;&#39;
    periods = Spectrum.periods_standard(until=6)
    spectrum = [Spectrum.chinese_point(p, 
                                       intensity=intensity,
                                       major=major,
                                       site=site,
                                       group=group,
                                       damping=damping) for p in periods]
    return Spectrum(periods, spectrum)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.chinese_point"><code class="name flex">
<span>def <span class="ident">chinese_point</span></span>(<span>period, intensity, major, site, group, damping=0.05)</span>
</code></dt>
<dd>
<section class="desc"><p>Get spectrum point for Chinese code, given a period.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>period</code> : number<br>
The given period.
</p>
<p><code>intensity</code> : number<br>
Intensity represented by a number. <br>
Use 7.5 or 8.5 for half-level intensity.
</p>
<p><code>major</code> : boolean
If True, it's for major (rare) earthquake.<br>
If False, for minor (frequent) earthquake.
</p>
<p><code>site</code> : int
Site number (Roman number in the code. 0 for I0, 1 for I1.)
</p>
<p><code>group</code> : int<br>
Site class (Chinese number in the code.)
</p>
<p><code>damping</code> : float<br>
Spectrum damping.
</p>
<h2 id="returns">Returns</h2>
<p><code>value</code> : float
the specific spectrum point value corresponding to the period.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def chinese_point(period, intensity, major, site, group, damping=0.05):
    &#39;&#39;&#39;Get spectrum point for Chinese code, given a period.  

    Parameters
    ----------  
    `period` : number  
        The given period.  

    `intensity` : number  
        Intensity represented by a number.   
        Use 7.5 or 8.5 for half-level intensity.  

    `major` : boolean
        If True, it&#39;s for major (rare) earthquake.  
        If False, for minor (frequent) earthquake.  

    `site` : int
        Site number (Roman number in the code. 0 for I0, 1 for I1.)  

    `group` : int  
        Site class (Chinese number in the code.)  

    `damping` : float  
        Spectrum damping.  

    Returns
    -------  
    `value` : float
        the specific spectrum point value corresponding to the period.  
    &#39;&#39;&#39;
    # alpha max
    if intensity == 6:
        alphamax = 0.28 if major else 0.04
    elif intensity == 7:
        alphamax = 0.50 if major else 0.08
    elif intensity == 7.5:
        alphamax = 0.72 if major else 0.12
    elif intensity == 8:
        alphamax = 0.9 if major else 0.16
    elif intensity == 8.5:
        alphamax = 1.2 if major else 0.24
    elif intensity == 9:
        alphamax = 1.40 if major else 0.32
    else:
        raise(&#34;ERROR: intensity not in [6, 7, 7.5, 8, 8.5, 9]&#34;)
    # tg
    tg_table = [[0.20, 0.25, 0.35, 0.45, 0.65],
                [0.25, 0.3, 0.4, 0.55, 0.75],
                [0.3, 0.35, 0.45, 0.65, 0.9]]
    assert group in [1, 2, 3] and site in [0, 1, 2, 3, 4]
    tg = tg_table[group-1][site]
    # other parameters
    gamma = 0.9 + (0.05 - damping) / (0.3 + 6*damping)
    eta1 = 0.02 + (0.05 - damping) / (4 + 32*damping)
    eta2 = 1 + (0.05 - damping) / (0.08 + 1.6*damping)
    # calculate
    if period &lt; 0.1:
        return ((10*eta2 - 4.5) * period + 0.45) * alphamax
    elif period &lt; tg:
        return eta2 * alphamax
    elif period &lt; 5*tg:
        return (tg/period)**gamma * eta2 * alphamax
    elif period &lt;= 6:
        return (eta2 * 0.2**gamma - eta1 * (period-5*tg)) * alphamax
    else:
        return (eta2 * 0.2**gamma - eta1 * (6-5*tg)) * alphamax</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Load the spectrum from file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : str
</p>
<h2 id="returns">Returns</h2>
<p><code>spectrum</code> : <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a><br>
New instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(filename):
    &#39;&#39;&#39;Load the spectrum from file.  

    Parameters
    ----------
    `filename` : str  

    Returns
    -------
    `spectrum` : `Spectrum`  
        New instance.
    &#39;&#39;&#39;
    if not filename.endswith(&#39;.spectrum&#39;):
        filename += &#39;.spectrum&#39;
    with open(filename, &#39;r&#39;) as f:
        string = f.read()
    return Spectrum.read_json(string)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.periods_standard"><code class="name flex">
<span>def <span class="ident">periods_standard</span></span>(<span>until=6)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a standard sampling of the periods.<br>
The sampling points are more sparse with the increase of period.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>until</code> : number<br>
The end of the period sampling list. It should &gt;= 4.0.</p>
<h2 id="returns">Returns</h2>
<p><code>periods</code> : numpy.ndarray<br>
The standard sampling points.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def periods_standard(until=6):
    &#39;&#39;&#39;Get a standard sampling of the periods.  
    The sampling points are more sparse with the increase of period.  

    Parameters
    ----------  
    `until` : number  
        The end of the period sampling list. It should &gt;= 4.0.

    Returns
    -------
    `periods` : numpy.ndarray  
        The standard sampling points.
    &#39;&#39;&#39;
    assert until &gt;= 4
    return np.hstack([np.arange(0, 0.2, 0.01),
                      np.arange(0.2, 0.5, 0.02),
                      np.arange(0.5, 1.0, 0.05),
                      np.arange(1.0, 2.0, 0.1),
                      np.arange(2.0, 4.0, 0.2),
                      np.arange(4.0, until+0.5, 0.5)])</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.read_csv"><code class="name flex">
<span>def <span class="ident">read_csv</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Create an instance by reading the written csv file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : string<br>
The filename to read.</p>
<h2 id="returns">Returns</h2>
<p><code>spectrum</code> : <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a><br>
New instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_csv(filename):
    &#39;&#39;&#39;Create an instance by reading the written csv file.  

    Parameters
    ----------
    `filename` : string  
        The filename to read.

    Returns
    -------
    `spectrum` : `Spectrum`  
        New instance.
    &#39;&#39;&#39;
    if not filename.endswith(&#39;.csv&#39;):
        filename += &#39;.csv&#39;
    data = np.loadtxt(filename, delimiter=&#39;,&#39;)
    return Spectrum(periods=data[:, 0], spectrum=data[:, 1])</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.read_dict"><code class="name flex">
<span>def <span class="ident">read_dict</span></span>(<span>it)</span>
</code></dt>
<dd>
<section class="desc"><p>Create an instance from the dict.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>it</code> : dict<br>
The dict generated by <a title="pyearthquake.Spectrum.to_dict" href="#pyearthquake.Spectrum.to_dict"><code>Spectrum.to_dict()</code></a></p>
<h2 id="returns">Returns</h2>
<p><code>spectrum</code> : <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a><br>
New instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_dict(it):
    &#39;&#39;&#39;Create an instance from the dict.  

    Parameters
    ----------
    `it` : dict  
        The dict generated by `Spectrum.to_dict`

    Returns
    -------
    `spectrum` : `Spectrum`  
        New instance.
    &#39;&#39;&#39;
    return Spectrum(periods=it[&#39;periods&#39;], spectrum=it[&#39;spectrum&#39;])</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>string)</span>
</code></dt>
<dd>
<section class="desc"><p>Create an instance from json string.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>string</code> : str<br>
The json string </p>
<h2 id="returns">Returns</h2>
<p><code>spectrum</code> : <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a><br>
New instance.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_json(string):
    &#39;&#39;&#39;Create an instance from json string.  

    Parameters
    ----------
    `string` : str  
        The json string 

    Returns
    -------
    `spectrum` : `Spectrum`  
        New instance.
    &#39;&#39;&#39;
    it = json.loads(string)
    return Spectrum.read_dict(it)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyearthquake.Spectrum.periods"><code class="name">var <span class="ident">periods</span></code></dt>
<dd>
<section class="desc"><p>numpy.ndarray, sampling periods</p></section>
</dd>
<dt id="pyearthquake.Spectrum.spectrum"><code class="name">var <span class="ident">spectrum</span></code></dt>
<dd>
<section class="desc"><p>numpy.ndarray, spectrum corresponding to sampling periods.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyearthquake.Spectrum.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, period)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the spectrum value. Either a list or a number is accepted.<br>
If the period exceeds the largest sampling period, the last spectrum value is returned.<br>
The spectrum value not on sampling points are linearly interpolated.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>period</code> : number, list, numpy.ndarray<br>
The interested period.</p>
<h2 id="returns">Returns</h2>
<p><code>spectrum</code> : number, numpy.ndarray<br>
if period is list-like, return a ndarray.
if period is a number, return a number.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, period):
    &#39;&#39;&#39;Get the spectrum value. Either a list or a number is accepted.  
    If the period exceeds the largest sampling period, the last spectrum value is returned.  
    The spectrum value not on sampling points are linearly interpolated.  

    Parameters
    ----------
    `period` : number, list, numpy.ndarray  
        The interested period.

    Returns
    -------
    `spectrum` : number, numpy.ndarray  
        if period is list-like, return a ndarray.
        if period is a number, return a number.
    &#39;&#39;&#39;
    if not hasattr(period, &#39;__iter__&#39;):
        i = self.periods.searchsorted(period)
        if self.periods[i] == period:
            return self.spectrum[i]
        elif i &gt;= len(self.periods):
            print(&#34;Warning: given period exceeds the sampling range.&#34;)
            return self.spectrum[-1]
        else:
            return self.spectrum[i] - (self.spectrum[i]-self.spectrum[i-1]) / (self.periods[i] - self.periods[i-1]) * (self.periods[i] - period)
    else:
        return np.array([self.get(p) for p in period])</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, target, start, end, step=0.1)</span>
</code></dt>
<dd>
<section class="desc"><p>Match the current spectrum with a target spectrum. Use Least Square method.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>target</code> : <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a><br>
the spectrum to be matched.
</p>
<p><code>start</code>, <code>end</code> : float<br>
the matching period boundaries.
</p>
<p><code>step</code> : float
evenly sample the periods with the step.</p>
<h2 id="returns">Returns</h2>
<p><code>coefficient</code> : float<br>
the coefficient to match the current spectrum to the target.</p>
<p><code>srss</code> : float <br>
the srss after match.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(self, target, start, end, step=0.1):
    &#39;&#39;&#39;Match the current spectrum with a target spectrum. Use Least Square method.  

    Parameters  
    ----------  
    `target` : `Spectrum`  
        the spectrum to be matched.  

    `start`, `end` : float  
        the matching period boundaries.  

    `step` : float
        evenly sample the periods with the step.

    Returns
    -------
    `coefficient` : float  
        the coefficient to match the current spectrum to the target.

    `srss` : float   
        the srss after match.
    &#39;&#39;&#39;
    periods = np.arange(start, end+step, step)
    this_spectrum = np.array([self.get(p) for p in periods])
    that_spectrum = np.array([target.get(p) for p in periods])
    coefficient = sum(this_spectrum * that_spectrum) / sum(this_spectrum ** 2)
    srss = (np.sum((this_spectrum * coefficient - that_spectrum) ** 2)) ** 0.5
    return coefficient, srss</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, filename=None, engine='pyplot')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the spectrum.</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : string, None<br>
if None, show it. Else, save it to the filename
</p>
<p><code>engine</code> : 'pyplot' or 'plotly'<br>
Plot engine.</p>
<h2 id="outputs">Outputs</h2>
<p>A file with name <code>filename</code>.png or <code>filename</code>.html will be generated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, filename=None, engine=&#39;pyplot&#39;):
    &#39;&#39;&#39;Plot the spectrum.

    Parameters
    ----------
    `filename` : string, None  
        if None, show it. Else, save it to the filename  

    `engine` : &#39;pyplot&#39; or &#39;plotly&#39;  
        Plot engine.

    Outputs
    -------
    A file with name `filename`.png or `filename`.html will be generated.
    &#39;&#39;&#39;
    if engine == &#39;pyplot&#39;:
        plt.figure(figsize=(4, 3))
        plt.plot(self.periods, self.spectrum, marker=&#39;o&#39;)
        plt.xlabel(&#39;Period (s)&#39;)
        plt.ylabel(&#39;Spetrum&#39;)
        plt.xlim([0, self.periods[-1]])
        if filename is None:
            plt.show()
        else:
            plt.savefig(filename+&#39;.png&#39;, dpi=200)
    elif engine == &#39;plotly&#39;:
        fig = go.Figure()
        fig.add_scatter(dict(
            x=&#39;self.periods&#39;,
            y=&#39;self.spectrum&#39;,
            mode=&#39;lines+markers&#39;,
        ))
        if filename is None:
            fig.show()
        else:
            fig.write_html(filename+&#39;.html&#39;)
    else:
        print(&#39;ERROR: engine should be in &#34;pyplot&#34; or &#34;plotly&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Save the spectrum to a file. Currently use json form.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : string<br>
The file name to be saved. <br>
The extension '.spectrum' will be automatically added.
</p>
<h2 id="outputs">Outputs</h2>
<p>A file with name <code>filename</code>.spectrum will be generated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename):
    &#39;&#39;&#39;Save the spectrum to a file. Currently use json form.  

    Parameters
    ----------
    `filename` : string  
        The file name to be saved.   
        The extension &#39;.spectrum&#39; will be automatically added.  

    Outputs
    -------
    A file with name `filename`.spectrum will be generated.
    &#39;&#39;&#39;
    with open(filename + &#39;.spectrum&#39;, &#39;w&#39;) as f:
        f.write(self.to_json())</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, factor_x=1, factor_y=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Scale the spectrum.</p>
<h2 id="parameters">Parameters</h2>
<p><code>factor_x</code> : number<br>
scaling factor in x direction (periods)
</p>
<p><code>factor_y</code> : number<br>
scaling factor in y direction (spectrum)</p>
<h2 id="returns">Returns</h2>
<p><code>spectrum</code> : <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, factor_x=1, factor_y=1):
    &#39;&#39;&#39;Scale the spectrum.

    Parameters
    ----------
    `factor_x` : number  
        scaling factor in x direction (periods)  

    `factor_y` : number  
        scaling factor in y direction (spectrum)

    Returns
    -------
    `spectrum` : `Spectrum`
    &#39;&#39;&#39;
    return Spectrum(periods=self.periods*factor_x, spectrum=self.spectrum*factor_y)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert the instance properties to a dict.
</p>
<h2 id="returns">Returns</h2>
<p><code>it</code> : dict</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    &#39;&#39;&#39;Convert the instance properties to a dict.  

    Returns
    -------
    `it` : dict
    &#39;&#39;&#39;
    return dict(
        periods=self.periods.tolist(),
        spectrum=self.spectrum.tolist()
    )</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert the properties to json.
</p>
<h2 id="returns">Returns</h2>
<p><code>json</code> : string</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self):
    &#39;&#39;&#39;Convert the properties to json.  

    Returns
    -------
    `json` : string  
    &#39;&#39;&#39;
    return json.dumps(self.to_dict())</code></pre>
</details>
</dd>
<dt id="pyearthquake.Spectrum.write_csv"><code class="name flex">
<span>def <span class="ident">write_csv</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Write the spectrum to a csv file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : string<br>
The extension '.csv' will be automatically added.</p>
<h2 id="outputs">Outputs</h2>
<p>A file named <code>filename</code>.csv will be generated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_csv(self, filename):
    &#39;&#39;&#39;Write the spectrum to a csv file.  

    Parameters
    ----------
    `filename` : string  
        The extension &#39;.csv&#39; will be automatically added.

    Outputs
    -------
    A file named `filename`.csv will be generated.
    &#39;&#39;&#39;
    np.savetxt(filename+&#39;.csv&#39;, np.vstack(
        [self.periods, self.spectrum]).T, fmt=&#34;%.3f,%.7f&#34;, header=&#39;Period,Spectrum&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyearthquake.Suite"><code class="flex name class">
<span>class <span class="ident">Suite</span></span>
<span>(</span><span>folder, name, target_spectrum, period_bound)</span>
</code></dt>
<dd>
<section class="desc"><p>A class that contains mainly a series of <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a> instances,
and corresponding series of factors, matching the suite of motions to the target <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a>.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>folder</code> : str<br>
A path-like string for the suite.</p>
<p><code>name</code> : str
A specific name for the suite. The instance will be saved in '{folder}/{name}.suite'
</p>
<p><code>target_spectrum</code> : <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a><br>
The target spectrum of the suite.
</p>
<p><code>period_bound</code> : List<float> len=2<br>
The matching period boundaries.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Suite(object):
    &#39;&#39;&#39;A class that contains mainly a series of `Motion` instances, 
    and corresponding series of factors, matching the suite of motions to the target `Spectrum`.  
    &#39;&#39;&#39;

    def __init__(self, folder, name, target_spectrum, period_bound):
        &#39;&#39;&#39;
        Parameters
        ----------
        `folder` : str  
            A path-like string for the suite.

        `name` : str
            A specific name for the suite. The instance will be saved in &#39;{folder}/{name}.suite&#39;  

        `target_spectrum` : `Spectrum`  
            The target spectrum of the suite.  

        `period_bound` : List&lt;float&gt; len=2  
            The matching period boundaries.
        &#39;&#39;&#39;
        self.folder = folder
        &#39;&#39;&#39;str. See `Suite`&#39;&#39;&#39;
        os.makedirs(folder, exist_ok=True)
        self.name = name
        &#39;&#39;&#39;str. See `Suite`&#39;&#39;&#39;
        self.motions = []
        &#39;&#39;&#39;List&lt;`Motion`&gt;. Store all the motions.&#39;&#39;&#39;
        self.factors = []
        &#39;&#39;&#39;List&lt;float&gt;. Store all the factors that should be applied to the motions.&#39;&#39;&#39;
        self.target_spectrum = target_spectrum
        &#39;&#39;&#39;`Spectrum`. See `Suite`&#39;&#39;&#39;
        self.period_bound = period_bound
        &#39;&#39;&#39;List&lt;float&gt;. See `Suite`&#39;&#39;&#39;
        self.period_samples = np.linspace(period_bound[0], period_bound[1], 200)
        &#39;&#39;&#39;numpy.ndarray. The period within the `period_bound` is evenly sampled, with 200 points.&#39;&#39;&#39;
        self.spectrum_matrix = None
        &#39;&#39;&#39;numpy.ndarray. A matrix with shape (len(`Suite.period_samples`), len(`Suite.motions`)).
        This matrix times the `Suite.factors` vector products the average spectrum with `Suite.period_samples`.&#39;&#39;&#39;
        self.target_vector = target_spectrum.get(self.period_samples)
        &#39;&#39;&#39;numpy.ndarray. The vector generated by the target_spectrum sampling the `Suite.period_samples`&#39;&#39;&#39;

    def set_folder(self, folder):
        &#39;&#39;&#39;Reset the folder for the suite and the motions.

        Parameters
        ----------
        `folder` : str

        Outputs
        -------
        `Suite.folder` and `Suite.motions` will be changed.
        &#39;&#39;&#39;
        if folder is not None:
            self.folder = folder
            os.makedirs(folder, exist_ok=True)
            for mo in self.motions:
                mo.folder = folder

    def add_motion(self, motion, factor=1):
        &#39;&#39;&#39;Add motion to the suite together with a factor, to keep the lengths are identical.

        Parameters
        ----------
        `motion` : `Motion`

        `factor` : number

        Outputs
        -------
        `Suite.motions` and `Suite.factors` will be changed.
        &#39;&#39;&#39;
        self.motions.append(motion)
        self.factors.append(factor)

    def load_motions_from_names(self, names, folder=None):
        &#39;&#39;&#39;Give a list of name and the folder, load motions.

        Parameters
        ----------
        `names` : List&lt;str&gt;  
            The list of motion names.

        `folder` : str, None  
            The folder of the motions.  
            If is None, use `Suite.folder`

        Outputs
        -------
        `Suite.motions` and `Suite.factors` will be changed.
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        for name in names:
            mo = Motion.load(f&#39;{folder}/{name}.motion&#39;)
            self.add_motion(mo)
            print(f&#39;Loaded motion {mo.name}&#39;)
        self.reset_spectrum_matrix()

    def load_motions_from_folder(self, folder=None):
        &#39;&#39;&#39;Find all the .motion file from the given folder, and load them.  

        Parameters
        ----------
        `folder` : str, None   
            The folder to search the .motion files.  
            If is None, use `Suite.folder` instead.  

        Outputs
        -------
        `Suite.motions` and `Suite.factors` will be changed.
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        filenames = os.listdir(self.folder)
        for filename in filenames:
            if filename.endswith(&#39;.motion&#39;):
                mo = Motion.load(f&#39;{folder}/{filename}&#39;)
                self.add_motion(mo)
                print(f&#39;Loadad motion {mo.name}&#39;)
        self.reset_spectrum_matrix()

    def filter_by_IDs(self, ids, new_name, new_folder=None):
        &#39;&#39;&#39;Give a series of selected IDs, filter the motions.  

        Parameters
        ----------
        `ids` : List&lt;int&gt;  
            The list of indexes of the selected motions in the current suite.  

        `new_name` : str  

        `new_folder` : str, None

        Returns
        -------
        `suite` : `Suite`  
            A new suite with the selected motions and their factors only.  
        &#39;&#39;&#39;
        suite = self.copy()
        suite.name = new_name
        suite.set_folder(new_folder)
        suite.motions = [self.motions[i] for i in ids]
        suite.factors = [self.factors[i] for i in ids]
        suite.reset_spectrum_matrix()
        print(f&#39;The motions have been filtered. {len(ids)} motions remain.&#39;)
        return suite

    def filter_by_file(self, filename, new_name, new_folder=None):
        &#39;&#39;&#39;Give a file with indexes selected.  

        Parameters
        ----------
        Refer to `Suite.filter_by_IDs`.  

        Returns
        -------
        Refer to `Suite.filter_by_IDs`.  
        &#39;&#39;&#39;
        with open(filename, &#39;r&#39;) as f:
            lines = f.readlines()
        ids = [int(l) for l in lines]
        return self.filter_by_IDs(ids=ids, new_name=new_name, new_folder=new_folder)

    def get_average_spectrum(self):
        &#39;&#39;&#39;Return a spectrum which is the average spectrum of the suite.

        Outputs
        -------
        `spectrum` : `Spectrum`  
        &#39;&#39;&#39;
        periods = self.motions[0].spectrum.periods
        average_spectrum = self.motions[0].spectrum.spectrum * self.factors[0]
        for i in range(1, len(self.motions)):
            average_spectrum += self.motions[i].spectrum.get(periods) * self.factors[i]
        average_spectrum /= len(self.motions)
        return Spectrum(periods, average_spectrum)

    def get_srss(self):
        &#39;&#39;&#39;Get the srss of the current averate spectrum to the target spectrum in the period boundary.

        Returns
        -------
        `srss` : float
        &#39;&#39;&#39;
        return np.linalg.norm(np.matmul(self.spectrum_matrix, self.factors) - self.target_vector).item()

    def reset_spectrum_matrix(self):
        &#39;&#39;&#39;Reset the spectrum matrix, which produces the average spectrum 
        in the boundary by multiplying factors vector.
        This method should be called everytime `Suite.motions` change.

        Outputs
        -------
        `Suite.spectrum_matrix` and `Suite.target_vector` will be changed.  
        &#39;&#39;&#39;
        mat = np.zeros((len(self.period_samples), len(self.motions)))
        for i in range(len(self.motions)):
            spectrum = self.motions[i].spectrum.get(self.period_samples)
            mat[:, i] = spectrum / len(self.motions)
        self.spectrum_matrix = mat
        self.target_vector = self.target_spectrum.get(self.period_samples)

    def eliminate_neg(self):
        &#39;&#39;&#39;Eliminate negative target vector by multiplying a factor for every individual.
        In other words, make the average spectrum above the target spectrum.

        Returns
        -------
        `factor` : float  
            The global factor that should be applied to each of the factors.  

        Outputs
        -------
        `Suite.factors` are all amplified by the returned `factor`.
        &#39;&#39;&#39;
        error = np.matmul(self.spectrum_matrix, self.factors) - self.target_vector
        argmin = np.argmin(error)
        factor = 1 / (1 + error[argmin] / self.target_vector[argmin])
        print(f&#39;Multiply {factor:.4} to eliminate negative spectrum.&#39;)
        self.factors = [self.factors[i] * factor for i in range(len(self.factors))]
        return factor

    def match_individual_LSQ(self):
        &#39;&#39;&#39;Use Least square method for each individual motion to match the spectrum.

        Returns
        -------
        `residuals` : numpy.ndarray  
            srss of each motion matched to the target spectrum.  

        Outputs
        -------
        `Suite.factors` are changed.
        &#39;&#39;&#39;
        residuals = np.zeros(len(self.motions))
        for i in range(len(self.motions)):
            this = self.spectrum_matrix[:, i] * len(self.motions)
            that = self.target_vector
            factor = np.dot(this, that) / np.dot(this, this)
            residual = np.linalg.norm(this * factor - that)
            self.factors[i] = factor
            residuals[i] = residual
        print(f&#34;Individual LSQ: Factor Max={np.max(self.factors):.4}, Residual Max={np.max(residuals):.4}&#34;)
        return residuals

    def filter_optimize(self, count, times, use_lsq=True, output_count=0, new_folder=None, lower_bound=0.6, upper_bound=1.4, dimension=100000):
        &#39;&#39;&#39;Use Monte Carlo simulation and Least Square method to optimize the suite.
        after running, a bunch of suites will be written to the new_folder.

        Parameters  
        ----------
        `count` : int  
            The number of motions in the resulting suite.  

        `times` : int  
            The number of times that MC simulation with dimension is run.  
            The total number of samples of MC simulation will be {times} * {dimension}.  

        `use_lsq` : boolean  
            Whether use LSQ optimizer to better optimize the suite.  

        `output_count` : int  
            The number of outputs. if 0, output all.  

        `new_folder` : str 
        `lower_bound`, `upper_bound` : float  
            For the purpose that the individual motions are not too far from the individually matched factors,
            the lower and upper boundaries of amplifying the individually matched factors are set.  
            This is only useful when `use_lsq` is set, to add boundaries to the LSQ optimizer.  

        `dimension` : int  
            Each time the Monte Carlo simulation is run, 
            means that {dimension} times of simulation have been done by using a matrix target.

        Returns
        -------
        List&lt;`Suite`&gt; with len=`output_count`.  
        The list is sorted. The best answer is the first result. However, visual check should be done.

        Outputs
        -------
        Every running after Monte Carlo simulation and LSQ optimization, the spectrum of the suite will be plotted.
        &#39;&#39;&#39;
        new_folder = new_folder if new_folder is not None else self.folder
        os.makedirs(new_folder, exist_ok=True)
        suites = []
        srsses = []
        for i in range(times):
            suite_new = self.filter_montecarlo(count=count, new_name=f&#39;mc{i:03d}&#39;, new_folder=new_folder)
            suites.append(suite_new)
            srsses.append(suite_new.get_srss())
            if use_lsq:
                suite_new2 = suite_new.optimize_LSQ(
                    new_name=f&#39;lsq{i:03d}&#39;, 
                    new_folder=new_folder, 
                    lower_bound=lower_bound, 
                    upper_bound=upper_bound
                )
                suites.append(suite_new2)
                srsses.append(suite_new2.get_srss())
        argsorted = np.argsort(np.array(srsses))
        results = [suites[i] for i in argsorted[:output_count]]
        for i, suite in enumerate(results):
            suite.name = f&#39;no{i}-{suite.name}&#39;
            suite.save()
            suite.plot_all_spectrums(engine=&#39;pyplot&#39;)
        return results

    def filter_montecarlo(self, count, new_name, new_folder=None, dimension=100000):
        &#39;&#39;&#39;Use Monte Carlo simulation to filter the suite to count numbers of motions.

        Parameters
        ---------- 
        Refer to `Suite.filter_optimize`.  

        Returns
        -------
        `suite` : `Suite`   
            The optimized result after {dimension} times of MC simulations.
        &#39;&#39;&#39;
        print(f&#39;Running Monte Carlo simulation, dimension={dimension}&#39;)
        self.match_individual_LSQ()
        factors = np.array(self.factors)
        xs = np.zeros((len(self.motions), dimension))
        for i in range(dimension):
            indexes = random.sample(range(len(self.motions)), count)
            xs[indexes, i] = factors[indexes]
        mul = np.matmul(self.spectrum_matrix * len(self.motions) / count, xs)
        loss = mul - self.target_vector.reshape(-1, 1)
        argmin = np.argmin(loss, axis=0)
        lossmin = np.min(loss, axis=0)
        target_at_lossmin = self.target_vector[argmin]
        amps = 1 / (lossmin / target_at_lossmin + 1)
        lossAmp = mul * amps - self.target_vector.reshape(-1, 1)
        srss = np.linalg.norm(lossAmp, axis=0)
        arg = np.argmin(srss)
        factors = xs[:, arg] * amps[arg]
        suvives = np.where(factors &gt; 1.0e-3)
        suite = self.copy()
        suite.name = new_name
        suite.set_folder(new_folder)
        suite.motions = [self.motions[i] for i in suvives[0]]
        suite.factors = [factors[i] for i in suvives[0]]
        suite.reset_spectrum_matrix()
        return suite

    def _loss(self, x):
        &#39;&#39;&#39;Utility function: calculate the loss for optimization.&#39;&#39;&#39;
        factors = x * np.array(self.factors)
        mul = np.matmul(self.spectrum_matrix, factors)
        loss = mul - self.target_vector
        argmin = np.argmin(loss)
        amp = 1 / (loss[argmin] / self.target_vector[argmin] + 1)
        return mul * amp - self.target_vector

    def optimize_LSQ(self, new_name, new_folder=None, lower_bound=0.6, upper_bound=1.4):
        &#39;&#39;&#39;Use Least Square method from scipy to optimize the factors.

        Parameters
        ----------
        Refer to `Suite.filter_optimize`.   

        Returns
        -------
        `suite` : `Suite`  
            Optimized suite.
        &#39;&#39;&#39;
        print(&#39;Running Bounded Least Square optimization ...&#39;)
        res = least_squares(self._loss,
                            np.ones(len(self.motions)),
                            bounds=(lower_bound, upper_bound),
                            verbose=0)
        factors = res.x * self.factors
        suite = self.copy()
        suite.name = new_name
        suite.set_folder(new_folder)
        suite.factors = factors.tolist()
        suite.eliminate_neg()
        return suite

    def load_peer_folder(self, peer_folder, h1=True, h2=True, v=False):
        &#39;&#39;&#39;From a folder load all the PEER motions into the suite.  
        Extract the downloaded peer zip file first.

        Parameters
        ----------
        `peer_folder` : str  
            The folder path of the extracted PEER data. Where `_SearchResults.csv` can be found.

        `h1`, `h2`, `v` : boolean  
            Whether load the three directional files or not.  

        Outputs
        -------
        `Suite.motions`, `Suite.factors` will be changed.  
        All the PEER motions will be saved in .motion format in the new folder.  
        &#39;&#39;&#39;
        with open(f&#39;{peer_folder}/_SearchResults.csv&#39;, &#34;r&#34;) as f:
            for _ in range(34):
                f.readline()
            i = 0
            positions = []
            if h1:
                positions.append(19)
            if h2:
                positions.append(20)
            if v:
                positions.append(21)
            line = f.readline()
            while line != &#39;\n&#39;:
                cells = line.split(&#39;,&#39;)
                for pos in positions:
                    filename = cells[pos].replace(&#39; &#39;, &#39;&#39;)
                    motion_name = filename.replace(&#39;.AT2&#39;, &#39;&#39;)
                    print(f&#39;Loading {motion_name}&#39;)
                    mo = Motion(folder=self.folder, name=motion_name)
                    mo.load_peer(peer_filename=f&#39;{peer_folder}/{filename}&#39;)
                    mo.generate_spectrum()
                    mo.save()
                    self.add_motion(mo)
                    i += 1
                line = f.readline()
        self.reset_spectrum_matrix()
        print(f&#34;Successfully loaded {i} earthquakes from peer folder {peer_folder} to {self.folder}.&#34;)
        return True

    def beautify(self, new_name, run_steps=[1,2,3,4], dt=0.01, new_folder=None, trunc_dict={}, left=1.0e-3, right=1.0e-3, prepend_zero=True):
        &#39;&#39;&#39;Beautify the suite in 4 steps:  

        1. truncate the motions, see `Motion.truncate`  
        2. trim the near-zero parts, see `Motion.trim` 
        3. change dt to uniform, see `Motion.change_dt`
        4. rename the motions to a series.  

        This procedure is always logged to the current folder.  

        Parameters
        ----------
        `new_name` : str  

        `run_steps` : List&lt;int&gt;  
            The step number to run. Users can select which one out of the 4 steps to run.
            The order will also follow this List.  

        `dt` : float  
            The uniform delta t.   

        `new_folder` : str  

        `trunc_dict` : dict  
            A dict that defines the `time` parameter in `Motion.truncate`  
            In the dict, keys are the indexes of the motions in the suite, values are the `time` values.

        `left`, `right` : float  
            The parameters of PGA to trim. Refer to `Motion.trim`.  

        Returns
        -------
        `suite` : `Suite`

        Outputs
        -------
        All the logs and the pre- and post- beautify average spectrum.
        &#39;&#39;&#39;
        suite = self.copy()
        spectrum_hist = suite.get_average_spectrum()
        suite.plot_all_spectrums(engine=&#39;pyplot&#39;)
        for i, motion in enumerate(self.motions):
            mo = motion.copy()
            mo.name = f&#39;{self.name}-{i}-b&#39;
            for step in run_steps:
                if step == 1:
                    if i in trunc_dict:
                        mo = mo.truncate(time=trunc_dict[i], new_name=mo.name+&#39;1&#39;)
                elif step == 2:
                    mo = mo.trim(new_name=mo.name+&#39;2&#39;, left=left, right=right)
                elif step == 3:
                    mo = mo.change_dt(dt=dt, new_name=mo.name+&#39;3&#39;)
                elif step == 4:
                    mo.name = f&#39;{i:02}&#39; if len(self.motions) &lt;= 100 else f&#39;{i:03}&#39;
                else:
                    print(f&#39;step={step} is not recognized and ignored.&#39;)
            suite.motions[i] = mo
        spectrum_new = suite.get_average_spectrum()
        plt.figure()
        plt.plot(spectrum_hist.periods, spectrum_hist.spectrum, label=&#39;before&#39;)
        plt.plot(spectrum_new.periods, spectrum_new.spectrum, label=&#39;after&#39;)
        plt.plot(suite.target_spectrum.periods, suite.target_spectrum.spectrum, label=&#39;target&#39;)
        plt.legend()
        plt.suptitle(f&#39;Beautify: {self.name} -&gt; {new_name}&#39;)
        plt.savefig(f&#39;{self.folder}/{self.name}-beautify.png&#39;, dpi=200)
        suite.name = new_name 
        if new_folder is not None:
            suite.set_folder(new_folder)
        return suite

    def scale(self, new_name, new_folder=None, factor_x=1, factor_y=1, scale_target_spectrum=True):
        &#39;&#39;&#39;Scale the motions both horizontally and vertically.  

        Parameters
        ----------
        `new_name` : str  

        `new_folder` : str, None  

        `factor_x`, `factor_y` : float  
            The factors to amplify in x axis and y axis.  

        `scale_target_spectrum` : boolean  
            Whether scale the target spectrum as well.

        Returns
        -------
        `suite` : `Suite`
        &#39;&#39;&#39;
        suite = self.copy()
        suite.name = new_name
        suite.set_folder(new_folder)
        for i, motion in enumerate(self.motions):
            suite.motions[i] = motion.scale(
                new_name=motion.name, factor_x=factor_x, factor_y=factor_y)
        if scale_target_spectrum:
            suite.target_spectrum = self.target_spectrum.scale(
                factor_x=factor_x, factor_y=factor_y)
        if factor_x != 1:
            suite.period_bound = [p * factor_x for p in self.period_bound]
            suite.period_samples = self.period_samples * factor_x
        suite.reset_spectrum_matrix()
        return suite

    def write_TCL(self, folder=None, filename=None):
        &#39;&#39;&#39;Write the suite to TCL forms for OpenSees.  
        Currently the TCL contains only one dict. 
        The keys of the dict is the motion names. Then the essential properties are stored.  
        At the same time, the accelerations for each motion is written to a text file.

        Parameters
        ----------
        `folder` : str, None  
            The folder to write the tcl files.
            If is None, use `Suite.folder`.

        `filename` :  str, None  
            The tcl file name. If is None, use `Suite.name`.

        Outputs
        -------
        A tcl file and a series of acceleration files.
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        filename = self.name if filename is None else filename.replace(
            &#39;.tcl&#39;, &#39;&#39;) + &#39;.tcl&#39;
        os.makedirs(folder, exist_ok=True)
        config = &#39;&#39;
        config += &#39;dict set motion keys {&#39;
        names = [mo.name for mo in self.motions]
        config += &#39; &#39;.join(names)
        config += &#39;}\n\n&#39;
        for i, mo in enumerate(self.motions):
            mo.write_accel(f&#39;{folder}/{mo.name}&#39;, time=False)
            config += f&#39;dict set motion {mo.name} path {folder}/{mo.name}\n&#39;
            config += f&#39;dict set motion {mo.name} npts {len(mo.accel)}\n&#39;
            config += f&#39;dict set motion {mo.name} dt {mo.dt:.4f}\n&#39;
            config += f&#39;dict set motion {mo.name} amp {self.factors[i]:.4f}\n\n&#39;
        with open(f&#39;{folder}/{filename}.tcl&#39;, &#39;w&#39;) as f:
            f.write(config)

    def plot_all_accels(self, folder=None, filename=None, save=True, engine=&#39;pyplot&#39;):
        &#39;&#39;&#39;Plot amplified accelograms to a single file.  

        Parameters
        ----------
        `folder` : str, None  
            If is None, use `Suite.folder`.

        `filename` : str, None  
            If is None, use `Suite.name` + &#39;_accel&#39;

        `save` : boolean  
            If True, save the file. Else, show immediately.  

        `engine` : &#39;pyplot&#39; or &#39;plotly&#39;  

        Outputs
        -------
        A figure is plotted.
        &#39;&#39;&#39;
        folder = self.folder if folder is None else folder
        if engine == &#39;plotly&#39;:
            filename = f&#39;{self.name}_accel.html&#39; if filename is None else filename + &#39;.html&#39;
            fig = go.Figure()
            for i, motion in enumerate(self.motions):
                fig.add_trace(go.Scatter(
                    x=np.arange(len(motion.accels)) * motion.dt,
                    y=motion.accels,
                    mode=&#39;lines&#39;,
                    name=str(i) + motion.name,
                    text=motion.name
                ))
            if save:
                fig.write_html(f&#39;{folder}/{filename}&#39;)
            else:
                fig.show()
        elif engine == &#39;pyplot&#39;:
            print(&#39;Pyplot is not supported.&#39;)
        else:
            print(&#39;ERROR: engine should be in &#34;pyplot&#34; and &#34;plotly&#34;&#39;)

    def plot_all_spectrums(self, folder=None, filename=None, save=True, engine=&#39;pyplot&#39;):
        &#39;&#39;&#39;Plot all amplified spectrums in one file.  

        Parameters
        ----------
        Refer to `Suite.plot_all_accels`. 

        The filename if is None will be `Suite.name` + &#39;_spectrum&#39;  

        Outputs
        -------
        A figure will be generated.
        &#39;&#39;&#39;
        if engine == &#39;plotly&#39;:
            folder = self.folder if folder is None else folder
            filename = f&#39;{self.name}_spectrum.html&#39; if filename is None else filename + &#39;.html&#39;
            fig = go.Figure()
            for i, motion in enumerate(self.motions):
                fig.add_trace(go.Scatter(
                    x=motion.spectrum.periods,
                    y=motion.spectrum.spectrum * self.factors[i],
                    mode=&#39;lines&#39;,
                    name=motion.name,
                    text=motion.name
                ))
            spectrum1 = self.target_spectrum
            spectrum2 = self.get_average_spectrum()
            fig.add_trace(go.Scatter(
                x=spectrum1.periods,
                y=spectrum1.spectrum,
                mode=&#39;lines&#39;,
                name=&#39;Target&#39;,
                text=&#39;Target&#39;,
                line=dict(width=5),
            ))
            fig.add_trace(go.Scatter(
                x=spectrum2.periods,
                y=spectrum2.spectrum,
                mode=&#39;lines&#39;,
                name=&#39;Average&#39;,
                text=&#39;Average&#39;,
                line=dict(width=5),
            ))
            if save:
                fig.write_html(f&#39;{folder}/{filename}&#39;)
            else:
                fig.show()
        elif engine == &#39;pyplot&#39;:
            folder = self.folder if folder is None else folder
            filename = f&#39;{self.name}_spectrum.png&#39; if filename is None else filename + &#39;.png&#39;
            plt.figure(figsize=(7, 5))
            for i, motion in enumerate(self.motions):
                plt.plot(motion.spectrum.periods, motion.spectrum.spectrum * self.factors[i], label=motion.name, c=&#39;silver&#39;)
            plt.plot(self.target_spectrum.periods, self.target_spectrum.spectrum, label=&#39;Target&#39;, linewidth=3)
            averageSpectrum = self.get_average_spectrum()
            plt.plot(averageSpectrum.periods, averageSpectrum.spectrum, label=&#34;average&#34;, linewidth=2)
            plt.legend(loc=&#39;best&#39;, fontsize=&#39;x-small&#39;)
            plt.title(f&#39;SRSS={self.get_srss():.4f}&#39;)
            if save:
                plt.savefig(os.path.join(folder, filename), dpi=200)
            else:
                plt.show()
        else:
            print(&#34;ERROR: wrong engine name. use &#39;plotly&#39; or &#39;pyplot&#39;.&#34;)

    def plot_individual(self, save=True):
        &#39;&#39;&#39;Plot all individual ground motions and the spectrum.

        Parameters
        ----------
        Refer to `Suite.plot_all_accels`.  

        Outputs
        -------
        If save, a figure for each motion will be generated.  
        &#39;&#39;&#39;
        for i, mo in enumerate(self.motions):
            _, ax = plt.subplots(2, 1, figsize=(7, 5))
            ax[0].plot(np.arange(len(mo.accel)) * mo.dt,
                        mo.accel * self.factors[i])
            ax[1].plot(mo.spectrum.periods,
                        mo.spectrum.spectrum * self.factors[i])
            ax[1].plot(self.target_spectrum.periods,
                        self.target_spectrum.spectrum, linewidth=2)
            plt.suptitle(
                f&#39;{i}: Name {mo.name}\nfactor={self.factors[i]:.4}, PGA={mo.get_PGA()*self.factors[i]:.4}, dt={mo.dt:.3f}&#39;)
            filename = f&#39;{self.folder}/motion{i}.png&#39;
            if save:
                plt.savefig(filename, dpi=200)
            else:
                plt.show()

    def plot_interactive(self, save=True):
        &#39;&#39;&#39;Plot the spectrum and the acceleration time-histories to an interactive html file.
        
        Parameters
        ----------
        `save` : boolean  
            If True, write to html file. Otherwise, show directly without saving.  
        
        Outputs
        -------
        A html file with interactive plotting sliders.
        &#39;&#39;&#39;
        fig = make_subplots(rows=1, cols=2)
        for i in range(len(self.motions)):
            fig.add_trace(go.Scatter(
                x=self.motions[i].spectrum.periods,
                y=self.motions[i].spectrum.spectrum * self.factors[i],
                name=self.motions[i].name,
            ), row=1, col=1)
            fig.add_trace(go.Scatter(
                x=self.motions[i].get_times(),
                y=self.motions[i].accel * self.factors[i],
                    name=self.motions[i].name,
            ), row=1, col=2)
        spectrum_average = self.get_average_spectrum()
        fig.add_trace(go.Scatter(
            x=spectrum_average.periods,
            y=spectrum_average.spectrum,
            name=&#39;average&#39;,
            line={&#39;width&#39;: 5}
        ))
        fig.add_trace(go.Scatter(
            x=self.target_spectrum.periods,
            y=self.target_spectrum.spectrum,
            name=&#39;target&#39;,
            line={&#39;width&#39;: 5}
        ))

        def _title(i):
            return f&#39;Motion #{i}: factor={self.factors[i]:.2f}, duration={len(self.motions[i].accel)*self.motions[i].dt:.2f}, PGA={self.motions[i].get_PGA()*self.factors[i]:.4}&#39;
        
        steps = []
        for i in range(len(self.motions)):
            step = dict(
                method=&#39;update&#39;,
                args=[
                    {&#39;visible&#39;: [j//2 == i for j in range(len(self.motions)*2)] + [False, True]},
                    {&#39;title&#39;: _title(i)}
                ],
                label=str(i),
            )
            steps.append(step)
        sliders = [dict(active=0, steps=steps, len=0.9, currentvalue={&#39;visible&#39;: False})]
        updatemenus = [dict(
            buttons=[dict(
                label=&#39;All&#39;,
                method=&#39;update&#39;,
                args=[
                    {&#39;visible&#39;: [True] * (len(self.motions)*2+2)},
                    {&#39;title&#39;: f&#39;Suite {self.name}: {len(self.motions)} motions, SRSS={self.get_srss():.4}&#39;}
                ]
            )],
            type=&#39;buttons&#39;,
            x=1,
            y=0,
            xanchor=&#39;right&#39;,
            yanchor=&#39;top&#39;,
            pad={&#39;t&#39;: 30},
        )]
        fig.update_layout(sliders=sliders, title=f&#39;Suite {self.name}: {len(self.motions)} motions, SRSS={self.get_srss():.4}&#39;, updatemenus=updatemenus)
        if save:
            fig.write_html(f&#39;{self.folder}/{self.name}.html&#39;)
        else:
            fig.show()
    
    def to_dict(self, separate_motion=True):
        &#39;&#39;&#39;Convert all the properties to dict.  

        Parameters
        ----------  
        `separate_motion` : boolean  
            If True, the motion details are not included into the dict.  
            User has to make sure these motions are not moved.

        Returns
        -------  
        `it` : dict  
        &#39;&#39;&#39;
        return dict(
            folder=self.folder,
            name=self.name,
            motions=[mo.to_dict() for mo in self.motions] if not separate_motion else [
                f&#39;{mo.folder}/{mo.name}&#39; for mo in self.motions],
            factors=self.factors if type(self.factors[0] == float) else [
                fact.item() for fact in self.factors],
            period_bound=self.period_bound,
            target_spectrum=self.target_spectrum.to_dict(),
            period_samples=self.period_samples.tolist(),
            srss=self.get_srss(),
            average_spectrum=self.get_average_spectrum().to_dict(),
        )

    def to_json(self, separate_motion=True):
        &#39;&#39;&#39;Convert the properties to json.  

        Parameters
        ----------
        Refer to `Suite.to_dict`.  

        Returns
        -------
        `json` : str
        &#39;&#39;&#39;
        return json.dumps(self.to_dict(separate_motion=separate_motion))

    def save(self, separate_motion=True, rewrite=False):
        &#39;&#39;&#39;Save the suite to a .suite file.  

        Parameters
        ----------  
        `separate_motion` : boolean  
            If True, the motion details are not included into the file.  
            User has to make sure the motions are not moved.

        `rewrite` : boolean   
            If True, all the &#39;.motion&#39; files will be rewritten.  
            otherwise, the motion files will be ignored.

        Outputs
        -------
        Create a .suite file to store the suite.
        &#39;&#39;&#39;
        with open(f&#39;{self.folder}/{self.name}.suite&#39;, &#39;w&#39;) as f:
            f.write(self.to_json(separate_motion=separate_motion))
        if separate_motion:
            for mo in self.motions:
                if not os.path.exists(f&#39;{mo.folder}/{mo.name}.motion&#39;):
                    mo.save()
                    print(f&#39;Motion saved to {mo.folder}/{mo.name}.motion&#39;)
                else:
                    if rewrite:
                        mo.save()
                        print(f&#39;Motion {mo.folder}/{mo.name}.motion is written.&#39;)
        print(f&#39;Saved to {self.folder}/{self.name}.suite&#39;)

    @staticmethod
    def read_dict(it):
        &#39;&#39;&#39;Read the dictionary representing the properties of the class.  
        If key &#39;motions&#39; is a instance of dict, then construct motions with dict.   
        else, key &#39;motions&#39; should be a list of {folder}/{name}, then construct with the .motion file.  

        Parameters
        ----------  
        `it` : dict  
            The dict generated by `Suite.to_dict`  

        Returns
        -------  
        `suite` : `Suite` 
        &#39;&#39;&#39;
        suite = Suite(
            folder=it[&#39;folder&#39;],
            name=it[&#39;name&#39;],
            target_spectrum=Spectrum.read_dict(it[&#39;target_spectrum&#39;]),
            period_bound=it[&#39;period_bound&#39;]
        )
        for i, mo_content in enumerate(it[&#39;motions&#39;]):
            if isinstance(mo_content, dict):
                suite.add_motion(Motion.read_dict(
                    mo_content), it[&#39;factors&#39;][i])
            else:
                suite.add_motion(Motion.load(
                    f&#39;{mo_content}.motion&#39;), it[&#39;factors&#39;][i])
        suite.period_samples = np.array(it[&#39;period_samples&#39;])
        suite.target_vector = suite.target_spectrum.get(suite.period_samples)
        suite.reset_spectrum_matrix()
        return suite

    @staticmethod
    def load(filename):
        &#39;&#39;&#39;Load a the suite from a file.  

        Parameters
        ----------
        `filename` : str  
            File that stores the suite.

        Returns
        -------
        `suite` : `Suite`
        &#39;&#39;&#39;
        if not filename.endswith(&#39;.suite&#39;):
            filename += &#39;.suite&#39;
        with open(filename, &#39;r&#39;) as f:
            return Suite.read_dict(json.loads(f.read()))

    def copy(self):
        &#39;&#39;&#39;Copy the instance.  
        Returns
        -------
        `suite` : `Suite`
        &#39;&#39;&#39;
        return Suite.read_dict(self.to_dict(separate_motion=False))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyearthquake.Suite.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Load a the suite from a file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>filename</code> : str<br>
File that stores the suite.</p>
<h2 id="returns">Returns</h2>
<p><code>suite</code> : <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(filename):
    &#39;&#39;&#39;Load a the suite from a file.  

    Parameters
    ----------
    `filename` : str  
        File that stores the suite.

    Returns
    -------
    `suite` : `Suite`
    &#39;&#39;&#39;
    if not filename.endswith(&#39;.suite&#39;):
        filename += &#39;.suite&#39;
    with open(filename, &#39;r&#39;) as f:
        return Suite.read_dict(json.loads(f.read()))</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.read_dict"><code class="name flex">
<span>def <span class="ident">read_dict</span></span>(<span>it)</span>
</code></dt>
<dd>
<section class="desc"><p>Read the dictionary representing the properties of the class.<br>
If key 'motions' is a instance of dict, then construct motions with dict. <br>
else, key 'motions' should be a list of {folder}/{name}, then construct with the .motion file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>it</code> : dict<br>
The dict generated by <a title="pyearthquake.Suite.to_dict" href="#pyearthquake.Suite.to_dict"><code>Suite.to_dict()</code></a>
</p>
<h2 id="returns">Returns</h2>
<p><code>suite</code> : <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read_dict(it):
    &#39;&#39;&#39;Read the dictionary representing the properties of the class.  
    If key &#39;motions&#39; is a instance of dict, then construct motions with dict.   
    else, key &#39;motions&#39; should be a list of {folder}/{name}, then construct with the .motion file.  

    Parameters
    ----------  
    `it` : dict  
        The dict generated by `Suite.to_dict`  

    Returns
    -------  
    `suite` : `Suite` 
    &#39;&#39;&#39;
    suite = Suite(
        folder=it[&#39;folder&#39;],
        name=it[&#39;name&#39;],
        target_spectrum=Spectrum.read_dict(it[&#39;target_spectrum&#39;]),
        period_bound=it[&#39;period_bound&#39;]
    )
    for i, mo_content in enumerate(it[&#39;motions&#39;]):
        if isinstance(mo_content, dict):
            suite.add_motion(Motion.read_dict(
                mo_content), it[&#39;factors&#39;][i])
        else:
            suite.add_motion(Motion.load(
                f&#39;{mo_content}.motion&#39;), it[&#39;factors&#39;][i])
    suite.period_samples = np.array(it[&#39;period_samples&#39;])
    suite.target_vector = suite.target_spectrum.get(suite.period_samples)
    suite.reset_spectrum_matrix()
    return suite</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyearthquake.Suite.factors"><code class="name">var <span class="ident">factors</span></code></dt>
<dd>
<section class="desc"><p>List<float>. Store all the factors that should be applied to the motions.</p></section>
</dd>
<dt id="pyearthquake.Suite.folder"><code class="name">var <span class="ident">folder</span></code></dt>
<dd>
<section class="desc"><p>str. See <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a></p></section>
</dd>
<dt id="pyearthquake.Suite.motions"><code class="name">var <span class="ident">motions</span></code></dt>
<dd>
<section class="desc"><p>List&lt;<a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a>&gt;. Store all the motions.</p></section>
</dd>
<dt id="pyearthquake.Suite.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>str. See <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a></p></section>
</dd>
<dt id="pyearthquake.Suite.period_bound"><code class="name">var <span class="ident">period_bound</span></code></dt>
<dd>
<section class="desc"><p>List<float>. See <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a></p></section>
</dd>
<dt id="pyearthquake.Suite.period_samples"><code class="name">var <span class="ident">period_samples</span></code></dt>
<dd>
<section class="desc"><p>numpy.ndarray. The period within the <code>period_bound</code> is evenly sampled, with 200 points.</p></section>
</dd>
<dt id="pyearthquake.Suite.spectrum_matrix"><code class="name">var <span class="ident">spectrum_matrix</span></code></dt>
<dd>
<section class="desc"><p>numpy.ndarray. A matrix with shape (len(<a title="pyearthquake.Suite.period_samples" href="#pyearthquake.Suite.period_samples"><code>Suite.period_samples</code></a>), len(<a title="pyearthquake.Suite.motions" href="#pyearthquake.Suite.motions"><code>Suite.motions</code></a>)).
This matrix times the <a title="pyearthquake.Suite.factors" href="#pyearthquake.Suite.factors"><code>Suite.factors</code></a> vector products the average spectrum with <a title="pyearthquake.Suite.period_samples" href="#pyearthquake.Suite.period_samples"><code>Suite.period_samples</code></a>.</p></section>
</dd>
<dt id="pyearthquake.Suite.target_spectrum"><code class="name">var <span class="ident">target_spectrum</span></code></dt>
<dd>
<section class="desc"><p><a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a>. See <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a></p></section>
</dd>
<dt id="pyearthquake.Suite.target_vector"><code class="name">var <span class="ident">target_vector</span></code></dt>
<dd>
<section class="desc"><p>numpy.ndarray. The vector generated by the target_spectrum sampling the <a title="pyearthquake.Suite.period_samples" href="#pyearthquake.Suite.period_samples"><code>Suite.period_samples</code></a></p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyearthquake.Suite.add_motion"><code class="name flex">
<span>def <span class="ident">add_motion</span></span>(<span>self, motion, factor=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Add motion to the suite together with a factor, to keep the lengths are identical.</p>
<h2 id="parameters">Parameters</h2>
<p><code>motion</code> : <a title="pyearthquake.Motion" href="#pyearthquake.Motion"><code>Motion</code></a></p>
<p><code>factor</code> : number</p>
<h2 id="outputs">Outputs</h2>
<p><a title="pyearthquake.Suite.motions" href="#pyearthquake.Suite.motions"><code>Suite.motions</code></a> and <a title="pyearthquake.Suite.factors" href="#pyearthquake.Suite.factors"><code>Suite.factors</code></a> will be changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_motion(self, motion, factor=1):
    &#39;&#39;&#39;Add motion to the suite together with a factor, to keep the lengths are identical.

    Parameters
    ----------
    `motion` : `Motion`

    `factor` : number

    Outputs
    -------
    `Suite.motions` and `Suite.factors` will be changed.
    &#39;&#39;&#39;
    self.motions.append(motion)
    self.factors.append(factor)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.beautify"><code class="name flex">
<span>def <span class="ident">beautify</span></span>(<span>self, new_name, run_steps=[1, 2, 3, 4], dt=0.01, new_folder=None, trunc_dict={}, left=0.001, right=0.001, prepend_zero=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Beautify the suite in 4 steps:
</p>
<ol>
<li>truncate the motions, see <a title="pyearthquake.Motion.truncate" href="#pyearthquake.Motion.truncate"><code>Motion.truncate()</code></a>
</li>
<li>trim the near-zero parts, see <a title="pyearthquake.Motion.trim" href="#pyearthquake.Motion.trim"><code>Motion.trim()</code></a> </li>
<li>change dt to uniform, see <a title="pyearthquake.Motion.change_dt" href="#pyearthquake.Motion.change_dt"><code>Motion.change_dt()</code></a></li>
<li>rename the motions to a series.
</li>
</ol>
<p>This procedure is always logged to the current folder.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>new_name</code> : str
</p>
<p><code>run_steps</code> : List<int><br>
The step number to run. Users can select which one out of the 4 steps to run.
The order will also follow this List.
</p>
<p><code>dt</code> : float<br>
The uniform delta t.
</p>
<p><code>new_folder</code> : str
</p>
<p><code>trunc_dict</code> : dict<br>
A dict that defines the <code>time</code> parameter in <a title="pyearthquake.Motion.truncate" href="#pyearthquake.Motion.truncate"><code>Motion.truncate()</code></a><br>
In the dict, keys are the indexes of the motions in the suite, values are the <code>time</code> values.</p>
<p><code>left</code>, <code>right</code> : float<br>
The parameters of PGA to trim. Refer to <a title="pyearthquake.Motion.trim" href="#pyearthquake.Motion.trim"><code>Motion.trim()</code></a>.
</p>
<h2 id="returns">Returns</h2>
<p><code>suite</code> : <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a></p>
<h2 id="outputs">Outputs</h2>
<p>All the logs and the pre- and post- beautify average spectrum.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beautify(self, new_name, run_steps=[1,2,3,4], dt=0.01, new_folder=None, trunc_dict={}, left=1.0e-3, right=1.0e-3, prepend_zero=True):
    &#39;&#39;&#39;Beautify the suite in 4 steps:  

    1. truncate the motions, see `Motion.truncate`  
    2. trim the near-zero parts, see `Motion.trim` 
    3. change dt to uniform, see `Motion.change_dt`
    4. rename the motions to a series.  

    This procedure is always logged to the current folder.  

    Parameters
    ----------
    `new_name` : str  

    `run_steps` : List&lt;int&gt;  
        The step number to run. Users can select which one out of the 4 steps to run.
        The order will also follow this List.  

    `dt` : float  
        The uniform delta t.   

    `new_folder` : str  

    `trunc_dict` : dict  
        A dict that defines the `time` parameter in `Motion.truncate`  
        In the dict, keys are the indexes of the motions in the suite, values are the `time` values.

    `left`, `right` : float  
        The parameters of PGA to trim. Refer to `Motion.trim`.  

    Returns
    -------
    `suite` : `Suite`

    Outputs
    -------
    All the logs and the pre- and post- beautify average spectrum.
    &#39;&#39;&#39;
    suite = self.copy()
    spectrum_hist = suite.get_average_spectrum()
    suite.plot_all_spectrums(engine=&#39;pyplot&#39;)
    for i, motion in enumerate(self.motions):
        mo = motion.copy()
        mo.name = f&#39;{self.name}-{i}-b&#39;
        for step in run_steps:
            if step == 1:
                if i in trunc_dict:
                    mo = mo.truncate(time=trunc_dict[i], new_name=mo.name+&#39;1&#39;)
            elif step == 2:
                mo = mo.trim(new_name=mo.name+&#39;2&#39;, left=left, right=right)
            elif step == 3:
                mo = mo.change_dt(dt=dt, new_name=mo.name+&#39;3&#39;)
            elif step == 4:
                mo.name = f&#39;{i:02}&#39; if len(self.motions) &lt;= 100 else f&#39;{i:03}&#39;
            else:
                print(f&#39;step={step} is not recognized and ignored.&#39;)
        suite.motions[i] = mo
    spectrum_new = suite.get_average_spectrum()
    plt.figure()
    plt.plot(spectrum_hist.periods, spectrum_hist.spectrum, label=&#39;before&#39;)
    plt.plot(spectrum_new.periods, spectrum_new.spectrum, label=&#39;after&#39;)
    plt.plot(suite.target_spectrum.periods, suite.target_spectrum.spectrum, label=&#39;target&#39;)
    plt.legend()
    plt.suptitle(f&#39;Beautify: {self.name} -&gt; {new_name}&#39;)
    plt.savefig(f&#39;{self.folder}/{self.name}-beautify.png&#39;, dpi=200)
    suite.name = new_name 
    if new_folder is not None:
        suite.set_folder(new_folder)
    return suite</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy the instance.<br>
Returns</p>
<hr>
<p><code>suite</code> : <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#39;&#39;&#39;Copy the instance.  
    Returns
    -------
    `suite` : `Suite`
    &#39;&#39;&#39;
    return Suite.read_dict(self.to_dict(separate_motion=False))</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.eliminate_neg"><code class="name flex">
<span>def <span class="ident">eliminate_neg</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Eliminate negative target vector by multiplying a factor for every individual.
In other words, make the average spectrum above the target spectrum.</p>
<h2 id="returns">Returns</h2>
<p><code>factor</code> : float<br>
The global factor that should be applied to each of the factors.
</p>
<h2 id="outputs">Outputs</h2>
<p><a title="pyearthquake.Suite.factors" href="#pyearthquake.Suite.factors"><code>Suite.factors</code></a> are all amplified by the returned <code>factor</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eliminate_neg(self):
    &#39;&#39;&#39;Eliminate negative target vector by multiplying a factor for every individual.
    In other words, make the average spectrum above the target spectrum.

    Returns
    -------
    `factor` : float  
        The global factor that should be applied to each of the factors.  

    Outputs
    -------
    `Suite.factors` are all amplified by the returned `factor`.
    &#39;&#39;&#39;
    error = np.matmul(self.spectrum_matrix, self.factors) - self.target_vector
    argmin = np.argmin(error)
    factor = 1 / (1 + error[argmin] / self.target_vector[argmin])
    print(f&#39;Multiply {factor:.4} to eliminate negative spectrum.&#39;)
    self.factors = [self.factors[i] * factor for i in range(len(self.factors))]
    return factor</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.filter_by_IDs"><code class="name flex">
<span>def <span class="ident">filter_by_IDs</span></span>(<span>self, ids, new_name, new_folder=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Give a series of selected IDs, filter the motions.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>ids</code> : List<int><br>
The list of indexes of the selected motions in the current suite.
</p>
<p><code>new_name</code> : str
</p>
<p><code>new_folder</code> : str, None</p>
<h2 id="returns">Returns</h2>
<p><code>suite</code> : <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a><br>
A new suite with the selected motions and their factors only.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_IDs(self, ids, new_name, new_folder=None):
    &#39;&#39;&#39;Give a series of selected IDs, filter the motions.  

    Parameters
    ----------
    `ids` : List&lt;int&gt;  
        The list of indexes of the selected motions in the current suite.  

    `new_name` : str  

    `new_folder` : str, None

    Returns
    -------
    `suite` : `Suite`  
        A new suite with the selected motions and their factors only.  
    &#39;&#39;&#39;
    suite = self.copy()
    suite.name = new_name
    suite.set_folder(new_folder)
    suite.motions = [self.motions[i] for i in ids]
    suite.factors = [self.factors[i] for i in ids]
    suite.reset_spectrum_matrix()
    print(f&#39;The motions have been filtered. {len(ids)} motions remain.&#39;)
    return suite</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.filter_by_file"><code class="name flex">
<span>def <span class="ident">filter_by_file</span></span>(<span>self, filename, new_name, new_folder=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Give a file with indexes selected.
</p>
<h2 id="parameters">Parameters</h2>
<p>Refer to <a title="pyearthquake.Suite.filter_by_IDs" href="#pyearthquake.Suite.filter_by_IDs"><code>Suite.filter_by_IDs()</code></a>.
</p>
<h2 id="returns">Returns</h2>
<p>Refer to <a title="pyearthquake.Suite.filter_by_IDs" href="#pyearthquake.Suite.filter_by_IDs"><code>Suite.filter_by_IDs()</code></a>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_by_file(self, filename, new_name, new_folder=None):
    &#39;&#39;&#39;Give a file with indexes selected.  

    Parameters
    ----------
    Refer to `Suite.filter_by_IDs`.  

    Returns
    -------
    Refer to `Suite.filter_by_IDs`.  
    &#39;&#39;&#39;
    with open(filename, &#39;r&#39;) as f:
        lines = f.readlines()
    ids = [int(l) for l in lines]
    return self.filter_by_IDs(ids=ids, new_name=new_name, new_folder=new_folder)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.filter_montecarlo"><code class="name flex">
<span>def <span class="ident">filter_montecarlo</span></span>(<span>self, count, new_name, new_folder=None, dimension=100000)</span>
</code></dt>
<dd>
<section class="desc"><p>Use Monte Carlo simulation to filter the suite to count numbers of motions.</p>
<h2 id="parameters">Parameters</h2>
<p>Refer to <a title="pyearthquake.Suite.filter_optimize" href="#pyearthquake.Suite.filter_optimize"><code>Suite.filter_optimize()</code></a>.
</p>
<h2 id="returns">Returns</h2>
<p><code>suite</code> : <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a> <br>
The optimized result after {dimension} times of MC simulations.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_montecarlo(self, count, new_name, new_folder=None, dimension=100000):
    &#39;&#39;&#39;Use Monte Carlo simulation to filter the suite to count numbers of motions.

    Parameters
    ---------- 
    Refer to `Suite.filter_optimize`.  

    Returns
    -------
    `suite` : `Suite`   
        The optimized result after {dimension} times of MC simulations.
    &#39;&#39;&#39;
    print(f&#39;Running Monte Carlo simulation, dimension={dimension}&#39;)
    self.match_individual_LSQ()
    factors = np.array(self.factors)
    xs = np.zeros((len(self.motions), dimension))
    for i in range(dimension):
        indexes = random.sample(range(len(self.motions)), count)
        xs[indexes, i] = factors[indexes]
    mul = np.matmul(self.spectrum_matrix * len(self.motions) / count, xs)
    loss = mul - self.target_vector.reshape(-1, 1)
    argmin = np.argmin(loss, axis=0)
    lossmin = np.min(loss, axis=0)
    target_at_lossmin = self.target_vector[argmin]
    amps = 1 / (lossmin / target_at_lossmin + 1)
    lossAmp = mul * amps - self.target_vector.reshape(-1, 1)
    srss = np.linalg.norm(lossAmp, axis=0)
    arg = np.argmin(srss)
    factors = xs[:, arg] * amps[arg]
    suvives = np.where(factors &gt; 1.0e-3)
    suite = self.copy()
    suite.name = new_name
    suite.set_folder(new_folder)
    suite.motions = [self.motions[i] for i in suvives[0]]
    suite.factors = [factors[i] for i in suvives[0]]
    suite.reset_spectrum_matrix()
    return suite</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.filter_optimize"><code class="name flex">
<span>def <span class="ident">filter_optimize</span></span>(<span>self, count, times, use_lsq=True, output_count=0, new_folder=None, lower_bound=0.6, upper_bound=1.4, dimension=100000)</span>
</code></dt>
<dd>
<section class="desc"><p>Use Monte Carlo simulation and Least Square method to optimize the suite.
after running, a bunch of suites will be written to the new_folder.</p>
<h2 id="parameters">Parameters</h2>
<p><code>count</code> : int<br>
The number of motions in the resulting suite.
</p>
<p><code>times</code> : int<br>
The number of times that MC simulation with dimension is run.<br>
The total number of samples of MC simulation will be {times} * {dimension}.
</p>
<p><code>use_lsq</code> : boolean<br>
Whether use LSQ optimizer to better optimize the suite.
</p>
<p><code>output_count</code> : int<br>
The number of outputs. if 0, output all.
</p>
<p><code>new_folder</code> : str
<code>lower_bound</code>, <code>upper_bound</code> : float<br>
For the purpose that the individual motions are not too far from the individually matched factors,
the lower and upper boundaries of amplifying the individually matched factors are set.<br>
This is only useful when <code>use_lsq</code> is set, to add boundaries to the LSQ optimizer.
</p>
<p><code>dimension</code> : int<br>
Each time the Monte Carlo simulation is run,
means that {dimension} times of simulation have been done by using a matrix target.</p>
<h2 id="returns">Returns</h2>
<p>List&lt;<a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a>&gt; with len=<code>output_count</code>.<br>
The list is sorted. The best answer is the first result. However, visual check should be done.</p>
<h2 id="outputs">Outputs</h2>
<p>Every running after Monte Carlo simulation and LSQ optimization, the spectrum of the suite will be plotted.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_optimize(self, count, times, use_lsq=True, output_count=0, new_folder=None, lower_bound=0.6, upper_bound=1.4, dimension=100000):
    &#39;&#39;&#39;Use Monte Carlo simulation and Least Square method to optimize the suite.
    after running, a bunch of suites will be written to the new_folder.

    Parameters  
    ----------
    `count` : int  
        The number of motions in the resulting suite.  

    `times` : int  
        The number of times that MC simulation with dimension is run.  
        The total number of samples of MC simulation will be {times} * {dimension}.  

    `use_lsq` : boolean  
        Whether use LSQ optimizer to better optimize the suite.  

    `output_count` : int  
        The number of outputs. if 0, output all.  

    `new_folder` : str 
    `lower_bound`, `upper_bound` : float  
        For the purpose that the individual motions are not too far from the individually matched factors,
        the lower and upper boundaries of amplifying the individually matched factors are set.  
        This is only useful when `use_lsq` is set, to add boundaries to the LSQ optimizer.  

    `dimension` : int  
        Each time the Monte Carlo simulation is run, 
        means that {dimension} times of simulation have been done by using a matrix target.

    Returns
    -------
    List&lt;`Suite`&gt; with len=`output_count`.  
    The list is sorted. The best answer is the first result. However, visual check should be done.

    Outputs
    -------
    Every running after Monte Carlo simulation and LSQ optimization, the spectrum of the suite will be plotted.
    &#39;&#39;&#39;
    new_folder = new_folder if new_folder is not None else self.folder
    os.makedirs(new_folder, exist_ok=True)
    suites = []
    srsses = []
    for i in range(times):
        suite_new = self.filter_montecarlo(count=count, new_name=f&#39;mc{i:03d}&#39;, new_folder=new_folder)
        suites.append(suite_new)
        srsses.append(suite_new.get_srss())
        if use_lsq:
            suite_new2 = suite_new.optimize_LSQ(
                new_name=f&#39;lsq{i:03d}&#39;, 
                new_folder=new_folder, 
                lower_bound=lower_bound, 
                upper_bound=upper_bound
            )
            suites.append(suite_new2)
            srsses.append(suite_new2.get_srss())
    argsorted = np.argsort(np.array(srsses))
    results = [suites[i] for i in argsorted[:output_count]]
    for i, suite in enumerate(results):
        suite.name = f&#39;no{i}-{suite.name}&#39;
        suite.save()
        suite.plot_all_spectrums(engine=&#39;pyplot&#39;)
    return results</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.get_average_spectrum"><code class="name flex">
<span>def <span class="ident">get_average_spectrum</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a spectrum which is the average spectrum of the suite.</p>
<h2 id="outputs">Outputs</h2>
<p><code>spectrum</code> : <a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum"><code>Spectrum</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_average_spectrum(self):
    &#39;&#39;&#39;Return a spectrum which is the average spectrum of the suite.

    Outputs
    -------
    `spectrum` : `Spectrum`  
    &#39;&#39;&#39;
    periods = self.motions[0].spectrum.periods
    average_spectrum = self.motions[0].spectrum.spectrum * self.factors[0]
    for i in range(1, len(self.motions)):
        average_spectrum += self.motions[i].spectrum.get(periods) * self.factors[i]
    average_spectrum /= len(self.motions)
    return Spectrum(periods, average_spectrum)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.get_srss"><code class="name flex">
<span>def <span class="ident">get_srss</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the srss of the current averate spectrum to the target spectrum in the period boundary.</p>
<h2 id="returns">Returns</h2>
<p><code>srss</code> : float</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_srss(self):
    &#39;&#39;&#39;Get the srss of the current averate spectrum to the target spectrum in the period boundary.

    Returns
    -------
    `srss` : float
    &#39;&#39;&#39;
    return np.linalg.norm(np.matmul(self.spectrum_matrix, self.factors) - self.target_vector).item()</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.load_motions_from_folder"><code class="name flex">
<span>def <span class="ident">load_motions_from_folder</span></span>(<span>self, folder=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Find all the .motion file from the given folder, and load them.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>folder</code> : str, None <br>
The folder to search the .motion files.<br>
If is None, use <a title="pyearthquake.Suite.folder" href="#pyearthquake.Suite.folder"><code>Suite.folder</code></a> instead.
</p>
<h2 id="outputs">Outputs</h2>
<p><a title="pyearthquake.Suite.motions" href="#pyearthquake.Suite.motions"><code>Suite.motions</code></a> and <a title="pyearthquake.Suite.factors" href="#pyearthquake.Suite.factors"><code>Suite.factors</code></a> will be changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_motions_from_folder(self, folder=None):
    &#39;&#39;&#39;Find all the .motion file from the given folder, and load them.  

    Parameters
    ----------
    `folder` : str, None   
        The folder to search the .motion files.  
        If is None, use `Suite.folder` instead.  

    Outputs
    -------
    `Suite.motions` and `Suite.factors` will be changed.
    &#39;&#39;&#39;
    folder = self.folder if folder is None else folder
    filenames = os.listdir(self.folder)
    for filename in filenames:
        if filename.endswith(&#39;.motion&#39;):
            mo = Motion.load(f&#39;{folder}/{filename}&#39;)
            self.add_motion(mo)
            print(f&#39;Loadad motion {mo.name}&#39;)
    self.reset_spectrum_matrix()</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.load_motions_from_names"><code class="name flex">
<span>def <span class="ident">load_motions_from_names</span></span>(<span>self, names, folder=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Give a list of name and the folder, load motions.</p>
<h2 id="parameters">Parameters</h2>
<p><code>names</code> : List<str><br>
The list of motion names.</p>
<p><code>folder</code> : str, None<br>
The folder of the motions.<br>
If is None, use <a title="pyearthquake.Suite.folder" href="#pyearthquake.Suite.folder"><code>Suite.folder</code></a></p>
<h2 id="outputs">Outputs</h2>
<p><a title="pyearthquake.Suite.motions" href="#pyearthquake.Suite.motions"><code>Suite.motions</code></a> and <a title="pyearthquake.Suite.factors" href="#pyearthquake.Suite.factors"><code>Suite.factors</code></a> will be changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_motions_from_names(self, names, folder=None):
    &#39;&#39;&#39;Give a list of name and the folder, load motions.

    Parameters
    ----------
    `names` : List&lt;str&gt;  
        The list of motion names.

    `folder` : str, None  
        The folder of the motions.  
        If is None, use `Suite.folder`

    Outputs
    -------
    `Suite.motions` and `Suite.factors` will be changed.
    &#39;&#39;&#39;
    folder = self.folder if folder is None else folder
    for name in names:
        mo = Motion.load(f&#39;{folder}/{name}.motion&#39;)
        self.add_motion(mo)
        print(f&#39;Loaded motion {mo.name}&#39;)
    self.reset_spectrum_matrix()</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.load_peer_folder"><code class="name flex">
<span>def <span class="ident">load_peer_folder</span></span>(<span>self, peer_folder, h1=True, h2=True, v=False)</span>
</code></dt>
<dd>
<section class="desc"><p>From a folder load all the PEER motions into the suite.<br>
Extract the downloaded peer zip file first.</p>
<h2 id="parameters">Parameters</h2>
<p><code>peer_folder</code> : str<br>
The folder path of the extracted PEER data. Where <code>_SearchResults.csv</code> can be found.</p>
<p><code>h1</code>, <code>h2</code>, <code>v</code> : boolean<br>
Whether load the three directional files or not.
</p>
<h2 id="outputs">Outputs</h2>
<p><a title="pyearthquake.Suite.motions" href="#pyearthquake.Suite.motions"><code>Suite.motions</code></a>, <a title="pyearthquake.Suite.factors" href="#pyearthquake.Suite.factors"><code>Suite.factors</code></a> will be changed.<br>
All the PEER motions will be saved in .motion format in the new folder.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_peer_folder(self, peer_folder, h1=True, h2=True, v=False):
    &#39;&#39;&#39;From a folder load all the PEER motions into the suite.  
    Extract the downloaded peer zip file first.

    Parameters
    ----------
    `peer_folder` : str  
        The folder path of the extracted PEER data. Where `_SearchResults.csv` can be found.

    `h1`, `h2`, `v` : boolean  
        Whether load the three directional files or not.  

    Outputs
    -------
    `Suite.motions`, `Suite.factors` will be changed.  
    All the PEER motions will be saved in .motion format in the new folder.  
    &#39;&#39;&#39;
    with open(f&#39;{peer_folder}/_SearchResults.csv&#39;, &#34;r&#34;) as f:
        for _ in range(34):
            f.readline()
        i = 0
        positions = []
        if h1:
            positions.append(19)
        if h2:
            positions.append(20)
        if v:
            positions.append(21)
        line = f.readline()
        while line != &#39;\n&#39;:
            cells = line.split(&#39;,&#39;)
            for pos in positions:
                filename = cells[pos].replace(&#39; &#39;, &#39;&#39;)
                motion_name = filename.replace(&#39;.AT2&#39;, &#39;&#39;)
                print(f&#39;Loading {motion_name}&#39;)
                mo = Motion(folder=self.folder, name=motion_name)
                mo.load_peer(peer_filename=f&#39;{peer_folder}/{filename}&#39;)
                mo.generate_spectrum()
                mo.save()
                self.add_motion(mo)
                i += 1
            line = f.readline()
    self.reset_spectrum_matrix()
    print(f&#34;Successfully loaded {i} earthquakes from peer folder {peer_folder} to {self.folder}.&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.match_individual_LSQ"><code class="name flex">
<span>def <span class="ident">match_individual_LSQ</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use Least square method for each individual motion to match the spectrum.</p>
<h2 id="returns">Returns</h2>
<p><code>residuals</code> : numpy.ndarray<br>
srss of each motion matched to the target spectrum.
</p>
<h2 id="outputs">Outputs</h2>
<p><a title="pyearthquake.Suite.factors" href="#pyearthquake.Suite.factors"><code>Suite.factors</code></a> are changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_individual_LSQ(self):
    &#39;&#39;&#39;Use Least square method for each individual motion to match the spectrum.

    Returns
    -------
    `residuals` : numpy.ndarray  
        srss of each motion matched to the target spectrum.  

    Outputs
    -------
    `Suite.factors` are changed.
    &#39;&#39;&#39;
    residuals = np.zeros(len(self.motions))
    for i in range(len(self.motions)):
        this = self.spectrum_matrix[:, i] * len(self.motions)
        that = self.target_vector
        factor = np.dot(this, that) / np.dot(this, this)
        residual = np.linalg.norm(this * factor - that)
        self.factors[i] = factor
        residuals[i] = residual
    print(f&#34;Individual LSQ: Factor Max={np.max(self.factors):.4}, Residual Max={np.max(residuals):.4}&#34;)
    return residuals</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.optimize_LSQ"><code class="name flex">
<span>def <span class="ident">optimize_LSQ</span></span>(<span>self, new_name, new_folder=None, lower_bound=0.6, upper_bound=1.4)</span>
</code></dt>
<dd>
<section class="desc"><p>Use Least Square method from scipy to optimize the factors.</p>
<h2 id="parameters">Parameters</h2>
<p>Refer to <a title="pyearthquake.Suite.filter_optimize" href="#pyearthquake.Suite.filter_optimize"><code>Suite.filter_optimize()</code></a>.
</p>
<h2 id="returns">Returns</h2>
<p><code>suite</code> : <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a><br>
Optimized suite.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize_LSQ(self, new_name, new_folder=None, lower_bound=0.6, upper_bound=1.4):
    &#39;&#39;&#39;Use Least Square method from scipy to optimize the factors.

    Parameters
    ----------
    Refer to `Suite.filter_optimize`.   

    Returns
    -------
    `suite` : `Suite`  
        Optimized suite.
    &#39;&#39;&#39;
    print(&#39;Running Bounded Least Square optimization ...&#39;)
    res = least_squares(self._loss,
                        np.ones(len(self.motions)),
                        bounds=(lower_bound, upper_bound),
                        verbose=0)
    factors = res.x * self.factors
    suite = self.copy()
    suite.name = new_name
    suite.set_folder(new_folder)
    suite.factors = factors.tolist()
    suite.eliminate_neg()
    return suite</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.plot_all_accels"><code class="name flex">
<span>def <span class="ident">plot_all_accels</span></span>(<span>self, folder=None, filename=None, save=True, engine='pyplot')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot amplified accelograms to a single file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>folder</code> : str, None<br>
If is None, use <a title="pyearthquake.Suite.folder" href="#pyearthquake.Suite.folder"><code>Suite.folder</code></a>.</p>
<p><code>filename</code> : str, None<br>
If is None, use <a title="pyearthquake.Suite.name" href="#pyearthquake.Suite.name"><code>Suite.name</code></a> + '_accel'</p>
<p><code>save</code> : boolean<br>
If True, save the file. Else, show immediately.
</p>
<p><code>engine</code> : 'pyplot' or 'plotly'
</p>
<h2 id="outputs">Outputs</h2>
<p>A figure is plotted.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_all_accels(self, folder=None, filename=None, save=True, engine=&#39;pyplot&#39;):
    &#39;&#39;&#39;Plot amplified accelograms to a single file.  

    Parameters
    ----------
    `folder` : str, None  
        If is None, use `Suite.folder`.

    `filename` : str, None  
        If is None, use `Suite.name` + &#39;_accel&#39;

    `save` : boolean  
        If True, save the file. Else, show immediately.  

    `engine` : &#39;pyplot&#39; or &#39;plotly&#39;  

    Outputs
    -------
    A figure is plotted.
    &#39;&#39;&#39;
    folder = self.folder if folder is None else folder
    if engine == &#39;plotly&#39;:
        filename = f&#39;{self.name}_accel.html&#39; if filename is None else filename + &#39;.html&#39;
        fig = go.Figure()
        for i, motion in enumerate(self.motions):
            fig.add_trace(go.Scatter(
                x=np.arange(len(motion.accels)) * motion.dt,
                y=motion.accels,
                mode=&#39;lines&#39;,
                name=str(i) + motion.name,
                text=motion.name
            ))
        if save:
            fig.write_html(f&#39;{folder}/{filename}&#39;)
        else:
            fig.show()
    elif engine == &#39;pyplot&#39;:
        print(&#39;Pyplot is not supported.&#39;)
    else:
        print(&#39;ERROR: engine should be in &#34;pyplot&#34; and &#34;plotly&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.plot_all_spectrums"><code class="name flex">
<span>def <span class="ident">plot_all_spectrums</span></span>(<span>self, folder=None, filename=None, save=True, engine='pyplot')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot all amplified spectrums in one file.
</p>
<h2 id="parameters">Parameters</h2>
<p>Refer to <a title="pyearthquake.Suite.plot_all_accels" href="#pyearthquake.Suite.plot_all_accels"><code>Suite.plot_all_accels()</code></a>. </p>
<p>The filename if is None will be <a title="pyearthquake.Suite.name" href="#pyearthquake.Suite.name"><code>Suite.name</code></a> + '_spectrum'
</p>
<h2 id="outputs">Outputs</h2>
<p>A figure will be generated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_all_spectrums(self, folder=None, filename=None, save=True, engine=&#39;pyplot&#39;):
    &#39;&#39;&#39;Plot all amplified spectrums in one file.  

    Parameters
    ----------
    Refer to `Suite.plot_all_accels`. 

    The filename if is None will be `Suite.name` + &#39;_spectrum&#39;  

    Outputs
    -------
    A figure will be generated.
    &#39;&#39;&#39;
    if engine == &#39;plotly&#39;:
        folder = self.folder if folder is None else folder
        filename = f&#39;{self.name}_spectrum.html&#39; if filename is None else filename + &#39;.html&#39;
        fig = go.Figure()
        for i, motion in enumerate(self.motions):
            fig.add_trace(go.Scatter(
                x=motion.spectrum.periods,
                y=motion.spectrum.spectrum * self.factors[i],
                mode=&#39;lines&#39;,
                name=motion.name,
                text=motion.name
            ))
        spectrum1 = self.target_spectrum
        spectrum2 = self.get_average_spectrum()
        fig.add_trace(go.Scatter(
            x=spectrum1.periods,
            y=spectrum1.spectrum,
            mode=&#39;lines&#39;,
            name=&#39;Target&#39;,
            text=&#39;Target&#39;,
            line=dict(width=5),
        ))
        fig.add_trace(go.Scatter(
            x=spectrum2.periods,
            y=spectrum2.spectrum,
            mode=&#39;lines&#39;,
            name=&#39;Average&#39;,
            text=&#39;Average&#39;,
            line=dict(width=5),
        ))
        if save:
            fig.write_html(f&#39;{folder}/{filename}&#39;)
        else:
            fig.show()
    elif engine == &#39;pyplot&#39;:
        folder = self.folder if folder is None else folder
        filename = f&#39;{self.name}_spectrum.png&#39; if filename is None else filename + &#39;.png&#39;
        plt.figure(figsize=(7, 5))
        for i, motion in enumerate(self.motions):
            plt.plot(motion.spectrum.periods, motion.spectrum.spectrum * self.factors[i], label=motion.name, c=&#39;silver&#39;)
        plt.plot(self.target_spectrum.periods, self.target_spectrum.spectrum, label=&#39;Target&#39;, linewidth=3)
        averageSpectrum = self.get_average_spectrum()
        plt.plot(averageSpectrum.periods, averageSpectrum.spectrum, label=&#34;average&#34;, linewidth=2)
        plt.legend(loc=&#39;best&#39;, fontsize=&#39;x-small&#39;)
        plt.title(f&#39;SRSS={self.get_srss():.4f}&#39;)
        if save:
            plt.savefig(os.path.join(folder, filename), dpi=200)
        else:
            plt.show()
    else:
        print(&#34;ERROR: wrong engine name. use &#39;plotly&#39; or &#39;pyplot&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.plot_individual"><code class="name flex">
<span>def <span class="ident">plot_individual</span></span>(<span>self, save=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot all individual ground motions and the spectrum.</p>
<h2 id="parameters">Parameters</h2>
<p>Refer to <a title="pyearthquake.Suite.plot_all_accels" href="#pyearthquake.Suite.plot_all_accels"><code>Suite.plot_all_accels()</code></a>.
</p>
<h2 id="outputs">Outputs</h2>
<p>If save, a figure for each motion will be generated.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_individual(self, save=True):
    &#39;&#39;&#39;Plot all individual ground motions and the spectrum.

    Parameters
    ----------
    Refer to `Suite.plot_all_accels`.  

    Outputs
    -------
    If save, a figure for each motion will be generated.  
    &#39;&#39;&#39;
    for i, mo in enumerate(self.motions):
        _, ax = plt.subplots(2, 1, figsize=(7, 5))
        ax[0].plot(np.arange(len(mo.accel)) * mo.dt,
                    mo.accel * self.factors[i])
        ax[1].plot(mo.spectrum.periods,
                    mo.spectrum.spectrum * self.factors[i])
        ax[1].plot(self.target_spectrum.periods,
                    self.target_spectrum.spectrum, linewidth=2)
        plt.suptitle(
            f&#39;{i}: Name {mo.name}\nfactor={self.factors[i]:.4}, PGA={mo.get_PGA()*self.factors[i]:.4}, dt={mo.dt:.3f}&#39;)
        filename = f&#39;{self.folder}/motion{i}.png&#39;
        if save:
            plt.savefig(filename, dpi=200)
        else:
            plt.show()</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.plot_interactive"><code class="name flex">
<span>def <span class="ident">plot_interactive</span></span>(<span>self, save=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the spectrum and the acceleration time-histories to an interactive html file.</p>
<h2 id="parameters">Parameters</h2>
<p><code>save</code> : boolean<br>
If True, write to html file. Otherwise, show directly without saving.
</p>
<h2 id="outputs">Outputs</h2>
<p>A html file with interactive plotting sliders.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_interactive(self, save=True):
    &#39;&#39;&#39;Plot the spectrum and the acceleration time-histories to an interactive html file.
    
    Parameters
    ----------
    `save` : boolean  
        If True, write to html file. Otherwise, show directly without saving.  
    
    Outputs
    -------
    A html file with interactive plotting sliders.
    &#39;&#39;&#39;
    fig = make_subplots(rows=1, cols=2)
    for i in range(len(self.motions)):
        fig.add_trace(go.Scatter(
            x=self.motions[i].spectrum.periods,
            y=self.motions[i].spectrum.spectrum * self.factors[i],
            name=self.motions[i].name,
        ), row=1, col=1)
        fig.add_trace(go.Scatter(
            x=self.motions[i].get_times(),
            y=self.motions[i].accel * self.factors[i],
                name=self.motions[i].name,
        ), row=1, col=2)
    spectrum_average = self.get_average_spectrum()
    fig.add_trace(go.Scatter(
        x=spectrum_average.periods,
        y=spectrum_average.spectrum,
        name=&#39;average&#39;,
        line={&#39;width&#39;: 5}
    ))
    fig.add_trace(go.Scatter(
        x=self.target_spectrum.periods,
        y=self.target_spectrum.spectrum,
        name=&#39;target&#39;,
        line={&#39;width&#39;: 5}
    ))

    def _title(i):
        return f&#39;Motion #{i}: factor={self.factors[i]:.2f}, duration={len(self.motions[i].accel)*self.motions[i].dt:.2f}, PGA={self.motions[i].get_PGA()*self.factors[i]:.4}&#39;
    
    steps = []
    for i in range(len(self.motions)):
        step = dict(
            method=&#39;update&#39;,
            args=[
                {&#39;visible&#39;: [j//2 == i for j in range(len(self.motions)*2)] + [False, True]},
                {&#39;title&#39;: _title(i)}
            ],
            label=str(i),
        )
        steps.append(step)
    sliders = [dict(active=0, steps=steps, len=0.9, currentvalue={&#39;visible&#39;: False})]
    updatemenus = [dict(
        buttons=[dict(
            label=&#39;All&#39;,
            method=&#39;update&#39;,
            args=[
                {&#39;visible&#39;: [True] * (len(self.motions)*2+2)},
                {&#39;title&#39;: f&#39;Suite {self.name}: {len(self.motions)} motions, SRSS={self.get_srss():.4}&#39;}
            ]
        )],
        type=&#39;buttons&#39;,
        x=1,
        y=0,
        xanchor=&#39;right&#39;,
        yanchor=&#39;top&#39;,
        pad={&#39;t&#39;: 30},
    )]
    fig.update_layout(sliders=sliders, title=f&#39;Suite {self.name}: {len(self.motions)} motions, SRSS={self.get_srss():.4}&#39;, updatemenus=updatemenus)
    if save:
        fig.write_html(f&#39;{self.folder}/{self.name}.html&#39;)
    else:
        fig.show()</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.reset_spectrum_matrix"><code class="name flex">
<span>def <span class="ident">reset_spectrum_matrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Reset the spectrum matrix, which produces the average spectrum
in the boundary by multiplying factors vector.
This method should be called everytime <a title="pyearthquake.Suite.motions" href="#pyearthquake.Suite.motions"><code>Suite.motions</code></a> change.</p>
<h2 id="outputs">Outputs</h2>
<p><a title="pyearthquake.Suite.spectrum_matrix" href="#pyearthquake.Suite.spectrum_matrix"><code>Suite.spectrum_matrix</code></a> and <a title="pyearthquake.Suite.target_vector" href="#pyearthquake.Suite.target_vector"><code>Suite.target_vector</code></a> will be changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_spectrum_matrix(self):
    &#39;&#39;&#39;Reset the spectrum matrix, which produces the average spectrum 
    in the boundary by multiplying factors vector.
    This method should be called everytime `Suite.motions` change.

    Outputs
    -------
    `Suite.spectrum_matrix` and `Suite.target_vector` will be changed.  
    &#39;&#39;&#39;
    mat = np.zeros((len(self.period_samples), len(self.motions)))
    for i in range(len(self.motions)):
        spectrum = self.motions[i].spectrum.get(self.period_samples)
        mat[:, i] = spectrum / len(self.motions)
    self.spectrum_matrix = mat
    self.target_vector = self.target_spectrum.get(self.period_samples)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, separate_motion=True, rewrite=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Save the suite to a .suite file.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>separate_motion</code> : boolean<br>
If True, the motion details are not included into the file.<br>
User has to make sure the motions are not moved.</p>
<p><code>rewrite</code> : boolean <br>
If True, all the '.motion' files will be rewritten.<br>
otherwise, the motion files will be ignored.</p>
<h2 id="outputs">Outputs</h2>
<p>Create a .suite file to store the suite.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, separate_motion=True, rewrite=False):
    &#39;&#39;&#39;Save the suite to a .suite file.  

    Parameters
    ----------  
    `separate_motion` : boolean  
        If True, the motion details are not included into the file.  
        User has to make sure the motions are not moved.

    `rewrite` : boolean   
        If True, all the &#39;.motion&#39; files will be rewritten.  
        otherwise, the motion files will be ignored.

    Outputs
    -------
    Create a .suite file to store the suite.
    &#39;&#39;&#39;
    with open(f&#39;{self.folder}/{self.name}.suite&#39;, &#39;w&#39;) as f:
        f.write(self.to_json(separate_motion=separate_motion))
    if separate_motion:
        for mo in self.motions:
            if not os.path.exists(f&#39;{mo.folder}/{mo.name}.motion&#39;):
                mo.save()
                print(f&#39;Motion saved to {mo.folder}/{mo.name}.motion&#39;)
            else:
                if rewrite:
                    mo.save()
                    print(f&#39;Motion {mo.folder}/{mo.name}.motion is written.&#39;)
    print(f&#39;Saved to {self.folder}/{self.name}.suite&#39;)</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, new_name, new_folder=None, factor_x=1, factor_y=1, scale_target_spectrum=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Scale the motions both horizontally and vertically.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>new_name</code> : str
</p>
<p><code>new_folder</code> : str, None
</p>
<p><code>factor_x</code>, <code>factor_y</code> : float<br>
The factors to amplify in x axis and y axis.
</p>
<p><code>scale_target_spectrum</code> : boolean<br>
Whether scale the target spectrum as well.</p>
<h2 id="returns">Returns</h2>
<p><code>suite</code> : <a title="pyearthquake.Suite" href="#pyearthquake.Suite"><code>Suite</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, new_name, new_folder=None, factor_x=1, factor_y=1, scale_target_spectrum=True):
    &#39;&#39;&#39;Scale the motions both horizontally and vertically.  

    Parameters
    ----------
    `new_name` : str  

    `new_folder` : str, None  

    `factor_x`, `factor_y` : float  
        The factors to amplify in x axis and y axis.  

    `scale_target_spectrum` : boolean  
        Whether scale the target spectrum as well.

    Returns
    -------
    `suite` : `Suite`
    &#39;&#39;&#39;
    suite = self.copy()
    suite.name = new_name
    suite.set_folder(new_folder)
    for i, motion in enumerate(self.motions):
        suite.motions[i] = motion.scale(
            new_name=motion.name, factor_x=factor_x, factor_y=factor_y)
    if scale_target_spectrum:
        suite.target_spectrum = self.target_spectrum.scale(
            factor_x=factor_x, factor_y=factor_y)
    if factor_x != 1:
        suite.period_bound = [p * factor_x for p in self.period_bound]
        suite.period_samples = self.period_samples * factor_x
    suite.reset_spectrum_matrix()
    return suite</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.set_folder"><code class="name flex">
<span>def <span class="ident">set_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<section class="desc"><p>Reset the folder for the suite and the motions.</p>
<h2 id="parameters">Parameters</h2>
<p><code>folder</code> : str</p>
<h2 id="outputs">Outputs</h2>
<p><a title="pyearthquake.Suite.folder" href="#pyearthquake.Suite.folder"><code>Suite.folder</code></a> and <a title="pyearthquake.Suite.motions" href="#pyearthquake.Suite.motions"><code>Suite.motions</code></a> will be changed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_folder(self, folder):
    &#39;&#39;&#39;Reset the folder for the suite and the motions.

    Parameters
    ----------
    `folder` : str

    Outputs
    -------
    `Suite.folder` and `Suite.motions` will be changed.
    &#39;&#39;&#39;
    if folder is not None:
        self.folder = folder
        os.makedirs(folder, exist_ok=True)
        for mo in self.motions:
            mo.folder = folder</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, separate_motion=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert all the properties to dict.
</p>
<h2 id="parameters">Parameters</h2>
<p><code>separate_motion</code> : boolean<br>
If True, the motion details are not included into the dict.<br>
User has to make sure these motions are not moved.</p>
<h2 id="returns">Returns</h2>
<p><code>it</code> : dict</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, separate_motion=True):
    &#39;&#39;&#39;Convert all the properties to dict.  

    Parameters
    ----------  
    `separate_motion` : boolean  
        If True, the motion details are not included into the dict.  
        User has to make sure these motions are not moved.

    Returns
    -------  
    `it` : dict  
    &#39;&#39;&#39;
    return dict(
        folder=self.folder,
        name=self.name,
        motions=[mo.to_dict() for mo in self.motions] if not separate_motion else [
            f&#39;{mo.folder}/{mo.name}&#39; for mo in self.motions],
        factors=self.factors if type(self.factors[0] == float) else [
            fact.item() for fact in self.factors],
        period_bound=self.period_bound,
        target_spectrum=self.target_spectrum.to_dict(),
        period_samples=self.period_samples.tolist(),
        srss=self.get_srss(),
        average_spectrum=self.get_average_spectrum().to_dict(),
    )</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, separate_motion=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert the properties to json.
</p>
<h2 id="parameters">Parameters</h2>
<p>Refer to <a title="pyearthquake.Suite.to_dict" href="#pyearthquake.Suite.to_dict"><code>Suite.to_dict()</code></a>.
</p>
<h2 id="returns">Returns</h2>
<p><code>json</code> : str</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self, separate_motion=True):
    &#39;&#39;&#39;Convert the properties to json.  

    Parameters
    ----------
    Refer to `Suite.to_dict`.  

    Returns
    -------
    `json` : str
    &#39;&#39;&#39;
    return json.dumps(self.to_dict(separate_motion=separate_motion))</code></pre>
</details>
</dd>
<dt id="pyearthquake.Suite.write_TCL"><code class="name flex">
<span>def <span class="ident">write_TCL</span></span>(<span>self, folder=None, filename=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Write the suite to TCL forms for OpenSees.<br>
Currently the TCL contains only one dict.
The keys of the dict is the motion names. Then the essential properties are stored.<br>
At the same time, the accelerations for each motion is written to a text file.</p>
<h2 id="parameters">Parameters</h2>
<p><code>folder</code> : str, None<br>
The folder to write the tcl files.
If is None, use <a title="pyearthquake.Suite.folder" href="#pyearthquake.Suite.folder"><code>Suite.folder</code></a>.</p>
<p><code>filename</code> :
str, None<br>
The tcl file name. If is None, use <a title="pyearthquake.Suite.name" href="#pyearthquake.Suite.name"><code>Suite.name</code></a>.</p>
<h2 id="outputs">Outputs</h2>
<p>A tcl file and a series of acceleration files.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_TCL(self, folder=None, filename=None):
    &#39;&#39;&#39;Write the suite to TCL forms for OpenSees.  
    Currently the TCL contains only one dict. 
    The keys of the dict is the motion names. Then the essential properties are stored.  
    At the same time, the accelerations for each motion is written to a text file.

    Parameters
    ----------
    `folder` : str, None  
        The folder to write the tcl files.
        If is None, use `Suite.folder`.

    `filename` :  str, None  
        The tcl file name. If is None, use `Suite.name`.

    Outputs
    -------
    A tcl file and a series of acceleration files.
    &#39;&#39;&#39;
    folder = self.folder if folder is None else folder
    filename = self.name if filename is None else filename.replace(
        &#39;.tcl&#39;, &#39;&#39;) + &#39;.tcl&#39;
    os.makedirs(folder, exist_ok=True)
    config = &#39;&#39;
    config += &#39;dict set motion keys {&#39;
    names = [mo.name for mo in self.motions]
    config += &#39; &#39;.join(names)
    config += &#39;}\n\n&#39;
    for i, mo in enumerate(self.motions):
        mo.write_accel(f&#39;{folder}/{mo.name}&#39;, time=False)
        config += f&#39;dict set motion {mo.name} path {folder}/{mo.name}\n&#39;
        config += f&#39;dict set motion {mo.name} npts {len(mo.accel)}\n&#39;
        config += f&#39;dict set motion {mo.name} dt {mo.dt:.4f}\n&#39;
        config += f&#39;dict set motion {mo.name} amp {self.factors[i]:.4f}\n\n&#39;
    with open(f&#39;{folder}/{filename}.tcl&#39;, &#39;w&#39;) as f:
        f.write(config)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#features">Features</a></li>
<li><a href="#fact-sheet">Fact Sheet</a></li>
<li><a href="#content-briefing">Content Briefing</a></li>
<li><a href="#change-log">Change log:</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyearthquake.Motion" href="#pyearthquake.Motion">Motion</a></code></h4>
<ul class="two-column">
<li><code><a title="pyearthquake.Motion.accel" href="#pyearthquake.Motion.accel">accel</a></code></li>
<li><code><a title="pyearthquake.Motion.change_dt" href="#pyearthquake.Motion.change_dt">change_dt</a></code></li>
<li><code><a title="pyearthquake.Motion.convert_peer" href="#pyearthquake.Motion.convert_peer">convert_peer</a></code></li>
<li><code><a title="pyearthquake.Motion.copy" href="#pyearthquake.Motion.copy">copy</a></code></li>
<li><code><a title="pyearthquake.Motion.damping" href="#pyearthquake.Motion.damping">damping</a></code></li>
<li><code><a title="pyearthquake.Motion.dt" href="#pyearthquake.Motion.dt">dt</a></code></li>
<li><code><a title="pyearthquake.Motion.folder" href="#pyearthquake.Motion.folder">folder</a></code></li>
<li><code><a title="pyearthquake.Motion.generate_spectrum" href="#pyearthquake.Motion.generate_spectrum">generate_spectrum</a></code></li>
<li><code><a title="pyearthquake.Motion.get_PGA" href="#pyearthquake.Motion.get_PGA">get_PGA</a></code></li>
<li><code><a title="pyearthquake.Motion.get_duration" href="#pyearthquake.Motion.get_duration">get_duration</a></code></li>
<li><code><a title="pyearthquake.Motion.get_times" href="#pyearthquake.Motion.get_times">get_times</a></code></li>
<li><code><a title="pyearthquake.Motion.information" href="#pyearthquake.Motion.information">information</a></code></li>
<li><code><a title="pyearthquake.Motion.load" href="#pyearthquake.Motion.load">load</a></code></li>
<li><code><a title="pyearthquake.Motion.load_peer" href="#pyearthquake.Motion.load_peer">load_peer</a></code></li>
<li><code><a title="pyearthquake.Motion.name" href="#pyearthquake.Motion.name">name</a></code></li>
<li><code><a title="pyearthquake.Motion.plot" href="#pyearthquake.Motion.plot">plot</a></code></li>
<li><code><a title="pyearthquake.Motion.plot_timehistory" href="#pyearthquake.Motion.plot_timehistory">plot_timehistory</a></code></li>
<li><code><a title="pyearthquake.Motion.read_accel" href="#pyearthquake.Motion.read_accel">read_accel</a></code></li>
<li><code><a title="pyearthquake.Motion.read_dict" href="#pyearthquake.Motion.read_dict">read_dict</a></code></li>
<li><code><a title="pyearthquake.Motion.read_info" href="#pyearthquake.Motion.read_info">read_info</a></code></li>
<li><code><a title="pyearthquake.Motion.read_json" href="#pyearthquake.Motion.read_json">read_json</a></code></li>
<li><code><a title="pyearthquake.Motion.read_spectrum" href="#pyearthquake.Motion.read_spectrum">read_spectrum</a></code></li>
<li><code><a title="pyearthquake.Motion.save" href="#pyearthquake.Motion.save">save</a></code></li>
<li><code><a title="pyearthquake.Motion.scale" href="#pyearthquake.Motion.scale">scale</a></code></li>
<li><code><a title="pyearthquake.Motion.spectrum" href="#pyearthquake.Motion.spectrum">spectrum</a></code></li>
<li><code><a title="pyearthquake.Motion.to_dict" href="#pyearthquake.Motion.to_dict">to_dict</a></code></li>
<li><code><a title="pyearthquake.Motion.to_json" href="#pyearthquake.Motion.to_json">to_json</a></code></li>
<li><code><a title="pyearthquake.Motion.trim" href="#pyearthquake.Motion.trim">trim</a></code></li>
<li><code><a title="pyearthquake.Motion.truncate" href="#pyearthquake.Motion.truncate">truncate</a></code></li>
<li><code><a title="pyearthquake.Motion.write_accel" href="#pyearthquake.Motion.write_accel">write_accel</a></code></li>
<li><code><a title="pyearthquake.Motion.write_info" href="#pyearthquake.Motion.write_info">write_info</a></code></li>
<li><code><a title="pyearthquake.Motion.write_spectrum" href="#pyearthquake.Motion.write_spectrum">write_spectrum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyearthquake.Spectrum" href="#pyearthquake.Spectrum">Spectrum</a></code></h4>
<ul class="two-column">
<li><code><a title="pyearthquake.Spectrum.chinese" href="#pyearthquake.Spectrum.chinese">chinese</a></code></li>
<li><code><a title="pyearthquake.Spectrum.chinese_point" href="#pyearthquake.Spectrum.chinese_point">chinese_point</a></code></li>
<li><code><a title="pyearthquake.Spectrum.get" href="#pyearthquake.Spectrum.get">get</a></code></li>
<li><code><a title="pyearthquake.Spectrum.load" href="#pyearthquake.Spectrum.load">load</a></code></li>
<li><code><a title="pyearthquake.Spectrum.match" href="#pyearthquake.Spectrum.match">match</a></code></li>
<li><code><a title="pyearthquake.Spectrum.periods" href="#pyearthquake.Spectrum.periods">periods</a></code></li>
<li><code><a title="pyearthquake.Spectrum.periods_standard" href="#pyearthquake.Spectrum.periods_standard">periods_standard</a></code></li>
<li><code><a title="pyearthquake.Spectrum.plot" href="#pyearthquake.Spectrum.plot">plot</a></code></li>
<li><code><a title="pyearthquake.Spectrum.read_csv" href="#pyearthquake.Spectrum.read_csv">read_csv</a></code></li>
<li><code><a title="pyearthquake.Spectrum.read_dict" href="#pyearthquake.Spectrum.read_dict">read_dict</a></code></li>
<li><code><a title="pyearthquake.Spectrum.read_json" href="#pyearthquake.Spectrum.read_json">read_json</a></code></li>
<li><code><a title="pyearthquake.Spectrum.save" href="#pyearthquake.Spectrum.save">save</a></code></li>
<li><code><a title="pyearthquake.Spectrum.scale" href="#pyearthquake.Spectrum.scale">scale</a></code></li>
<li><code><a title="pyearthquake.Spectrum.spectrum" href="#pyearthquake.Spectrum.spectrum">spectrum</a></code></li>
<li><code><a title="pyearthquake.Spectrum.to_dict" href="#pyearthquake.Spectrum.to_dict">to_dict</a></code></li>
<li><code><a title="pyearthquake.Spectrum.to_json" href="#pyearthquake.Spectrum.to_json">to_json</a></code></li>
<li><code><a title="pyearthquake.Spectrum.write_csv" href="#pyearthquake.Spectrum.write_csv">write_csv</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyearthquake.Suite" href="#pyearthquake.Suite">Suite</a></code></h4>
<ul class="">
<li><code><a title="pyearthquake.Suite.add_motion" href="#pyearthquake.Suite.add_motion">add_motion</a></code></li>
<li><code><a title="pyearthquake.Suite.beautify" href="#pyearthquake.Suite.beautify">beautify</a></code></li>
<li><code><a title="pyearthquake.Suite.copy" href="#pyearthquake.Suite.copy">copy</a></code></li>
<li><code><a title="pyearthquake.Suite.eliminate_neg" href="#pyearthquake.Suite.eliminate_neg">eliminate_neg</a></code></li>
<li><code><a title="pyearthquake.Suite.factors" href="#pyearthquake.Suite.factors">factors</a></code></li>
<li><code><a title="pyearthquake.Suite.filter_by_IDs" href="#pyearthquake.Suite.filter_by_IDs">filter_by_IDs</a></code></li>
<li><code><a title="pyearthquake.Suite.filter_by_file" href="#pyearthquake.Suite.filter_by_file">filter_by_file</a></code></li>
<li><code><a title="pyearthquake.Suite.filter_montecarlo" href="#pyearthquake.Suite.filter_montecarlo">filter_montecarlo</a></code></li>
<li><code><a title="pyearthquake.Suite.filter_optimize" href="#pyearthquake.Suite.filter_optimize">filter_optimize</a></code></li>
<li><code><a title="pyearthquake.Suite.folder" href="#pyearthquake.Suite.folder">folder</a></code></li>
<li><code><a title="pyearthquake.Suite.get_average_spectrum" href="#pyearthquake.Suite.get_average_spectrum">get_average_spectrum</a></code></li>
<li><code><a title="pyearthquake.Suite.get_srss" href="#pyearthquake.Suite.get_srss">get_srss</a></code></li>
<li><code><a title="pyearthquake.Suite.load" href="#pyearthquake.Suite.load">load</a></code></li>
<li><code><a title="pyearthquake.Suite.load_motions_from_folder" href="#pyearthquake.Suite.load_motions_from_folder">load_motions_from_folder</a></code></li>
<li><code><a title="pyearthquake.Suite.load_motions_from_names" href="#pyearthquake.Suite.load_motions_from_names">load_motions_from_names</a></code></li>
<li><code><a title="pyearthquake.Suite.load_peer_folder" href="#pyearthquake.Suite.load_peer_folder">load_peer_folder</a></code></li>
<li><code><a title="pyearthquake.Suite.match_individual_LSQ" href="#pyearthquake.Suite.match_individual_LSQ">match_individual_LSQ</a></code></li>
<li><code><a title="pyearthquake.Suite.motions" href="#pyearthquake.Suite.motions">motions</a></code></li>
<li><code><a title="pyearthquake.Suite.name" href="#pyearthquake.Suite.name">name</a></code></li>
<li><code><a title="pyearthquake.Suite.optimize_LSQ" href="#pyearthquake.Suite.optimize_LSQ">optimize_LSQ</a></code></li>
<li><code><a title="pyearthquake.Suite.period_bound" href="#pyearthquake.Suite.period_bound">period_bound</a></code></li>
<li><code><a title="pyearthquake.Suite.period_samples" href="#pyearthquake.Suite.period_samples">period_samples</a></code></li>
<li><code><a title="pyearthquake.Suite.plot_all_accels" href="#pyearthquake.Suite.plot_all_accels">plot_all_accels</a></code></li>
<li><code><a title="pyearthquake.Suite.plot_all_spectrums" href="#pyearthquake.Suite.plot_all_spectrums">plot_all_spectrums</a></code></li>
<li><code><a title="pyearthquake.Suite.plot_individual" href="#pyearthquake.Suite.plot_individual">plot_individual</a></code></li>
<li><code><a title="pyearthquake.Suite.plot_interactive" href="#pyearthquake.Suite.plot_interactive">plot_interactive</a></code></li>
<li><code><a title="pyearthquake.Suite.read_dict" href="#pyearthquake.Suite.read_dict">read_dict</a></code></li>
<li><code><a title="pyearthquake.Suite.reset_spectrum_matrix" href="#pyearthquake.Suite.reset_spectrum_matrix">reset_spectrum_matrix</a></code></li>
<li><code><a title="pyearthquake.Suite.save" href="#pyearthquake.Suite.save">save</a></code></li>
<li><code><a title="pyearthquake.Suite.scale" href="#pyearthquake.Suite.scale">scale</a></code></li>
<li><code><a title="pyearthquake.Suite.set_folder" href="#pyearthquake.Suite.set_folder">set_folder</a></code></li>
<li><code><a title="pyearthquake.Suite.spectrum_matrix" href="#pyearthquake.Suite.spectrum_matrix">spectrum_matrix</a></code></li>
<li><code><a title="pyearthquake.Suite.target_spectrum" href="#pyearthquake.Suite.target_spectrum">target_spectrum</a></code></li>
<li><code><a title="pyearthquake.Suite.target_vector" href="#pyearthquake.Suite.target_vector">target_vector</a></code></li>
<li><code><a title="pyearthquake.Suite.to_dict" href="#pyearthquake.Suite.to_dict">to_dict</a></code></li>
<li><code><a title="pyearthquake.Suite.to_json" href="#pyearthquake.Suite.to_json">to_json</a></code></li>
<li><code><a title="pyearthquake.Suite.write_TCL" href="#pyearthquake.Suite.write_TCL">write_TCL</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>